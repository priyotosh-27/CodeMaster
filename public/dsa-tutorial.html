<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DSA Mastery Guide - CodeMaster Pro</title>

  <script src="https://cdn.tailwindcss.com"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Poppins:wght@600;700;800&family=Inter:wght@400;500;600&display=swap"
    rel="stylesheet">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js" defer></script>

  <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">
  <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>

  <style>
    /* CSS Variables for Theming and Topic Colors */
    :root {
      --navbar-height: 64px;
      --sidebar-width: 280px;
      --bg-primary: #f8fafc;
      --bg-secondary: #ffffff;
      --bg-sidebar: #f1f5f9;
      --text-primary: #1e293b;
      --text-secondary: #475569;
      --text-heading: #0f172a;
      --border-color: #e2e8f0;
      --shadow-color: rgba(99, 102, 241, 0.07);
      --accent-primary: #6366f1;
      --accent-secondary: #818cf8;
      --color-introduction: #0d9488;
      --color-complexity: #64748b;
      --color-arrays: #6366f1;
      --color-linkedlists: #8b5cf6;
      --color-stacks: #ec4899;
      --color-queues: #10b981;
      --color-trees: #22c55e;
      --color-graphs: #3b82f6;
      --color-searching: #f97316;
      --color-sorting: #eab308;
      --color-recursion: #ef4444;
      --color-backtracking: #d946ef;
      --color-dp: #14b8a6;
      --color-greedy: #f59e0b;
      --color-advancedtrees: #0ea5e9;
      --color-dsu: #6d28d9;
      --color-hashing: #78716c;
    }

    html[data-theme='dark'] {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-sidebar: #111827;
      --text-primary: #cbd5e1;
      --text-secondary: #94a3b8;
      --text-heading: #f8fafc;
      --border-color: #334155;
      --shadow-color: rgba(0, 0, 0, 0.2);
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: 'Inter', sans-serif;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      transition: background-color 0.3s, color 0.3s;
      padding-top: var(--navbar-height);
      /* Space for fixed navbar */
    }

    h1,
    h2,
    h3,
    h4 {
      font-family: 'Poppins', sans-serif;
      color: var(--text-heading);
    }

    /* Corrected Layout */
    nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: var(--navbar-height);
      z-index: 20;
      /* Ensure nav is on top */
    }

    #sidebar {
      position: fixed;
      top: var(--navbar-height);
      left: 0;
      bottom: 0;
      width: var(--sidebar-width);
      overflow-y: auto;
      /* This makes the sidebar scrollable */
      z-index: 10;
      background-color: var(--bg-sidebar);
      border-right: 1px solid var(--border-color);
    }

    #main-content {
      margin-left: var(--sidebar-width);
      /* Push content to the right of the sidebar */
    }

    /* End of Corrected Layout */

    /* Custom scrollbar styling */
    #sidebar::-webkit-scrollbar {
      width: 8px;
    }

    #sidebar::-webkit-scrollbar-track {
      background: transparent;
    }

    #sidebar::-webkit-scrollbar-thumb {
      background-color: var(--border-color);
      border-radius: 10px;
    }

    .sidebar a.active {
      background: var(--accent-primary);
      color: white !important;
    }

    .sidebar-link:hover {
      background-color: var(--border-color);
    }

    .topic-completed a {
      text-decoration: line-through;
      opacity: 0.6;
    }

    /* Content Styling */
    .topic-section {
      background: var(--bg-secondary);
      box-shadow: 0 4px 16px var(--shadow-color);
      border-top: 6px solid;
    }

    details>summary {
      cursor: pointer;
      font-weight: 600;
      padding: 0.5rem;
      border-radius: 0.375rem;
      transition: background-color 0.2s;
    }

    details>summary:hover {
      background-color: var(--bg-sidebar);
    }

    details>summary::marker {
      color: var(--accent-primary);
    }

    details[open]>summary {
      background-color: var(--bg-sidebar);
    }

    pre[class*="language-"] {
      position: relative;
    }

    .copy-code-btn {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: none;
      padding: 0.25rem 0.6rem;
      border-radius: 0.375rem;
      font-size: 0.8rem;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
    }

    pre:hover .copy-code-btn {
      opacity: 1;
    }

    /* Reading Progress Bar */
    #progressBar {
      position: fixed;
      top: 0;
      left: 0;
      height: 5px;
      background: var(--accent-primary);
      width: 0%;
      z-index: 30;
      /* Highest z-index */
      transition: width 0.1s linear;
    }

    /* Navigation Buttons */
    .nav-button {
      background-color: var(--bg-sidebar);
      border: 1px solid var(--border-color);
      transition: all 0.2s ease;
    }

    .nav-button:hover {
      background-color: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>

<body class="min-h-screen">

  <div id="progressBar"></div>

  <div id="app-container">
    <nav class="bg-white/80 dark:bg-gray-900/80 backdrop-blur-lg shadow-md z-50">
      <div class="container mx-auto px-6 py-3 flex justify-between items-center">
        <div class="flex items-center space-x-3">
          <i class="fas fa-laptop-code text-3xl text-indigo-500"></i>
          <span class="text-2xl font-bold">CodeMaster</span>
        </div>
        <div class="flex items-center gap-4">

          <div id="themeToggle"
            class="theme-switch text-xl cursor-pointer p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700">
            <i class="fas fa-sun"></i><i class="fas fa-moon"></i>
          </div>
        </div>
      </div>
    </nav>

    <div id="main-wrapper">
      <aside id="sidebar" class="sidebar p-6 border-r border-gray-200 dark:border-gray-800">
        <h3 class="text-xl font-bold mb-4">Topics</h3>
        <div id="sidebar-topics" class="space-y-1">
          <label class="flex items-center" data-topic-id="introduction"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#introduction" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-info-circle w-6"
                style="color:var(--color-introduction)"></i>Introduction</a></label>
          <label class="flex items-center" data-topic-id="complexity"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#complexity" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-tachometer-alt w-6"
                style="color:var(--color-complexity)"></i>Complexity</a></label>
          <label class="flex items-center" data-topic-id="arrays"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#arrays" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-th-large w-6"
                style="color:var(--color-arrays)"></i>Arrays</a></label>
          <label class="flex items-center" data-topic-id="linkedlists"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#linkedlists" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-link w-6"
                style="color:var(--color-linkedlists)"></i>Linked
              Lists</a></label>
          <label class="flex items-center" data-topic-id="stacks"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#stacks" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-layer-group w-6"
                style="color:var(--color-stacks)"></i>Stacks</a></label>
          <label class="flex items-center" data-topic-id="queues"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#queues" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-stream w-6"
                style="color:var(--color-queues)"></i>Queues</a></label>
          <label class="flex items-center" data-topic-id="trees"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#trees" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-tree w-6"
                style="color:var(--color-trees)"></i>Trees</a></label>
          <label class="flex items-center" data-topic-id="graphs"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#graphs" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-project-diagram w-6"
                style="color:var(--color-graphs)"></i>Graphs</a></label>
          <label class="flex items-center" data-topic-id="searching"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#searching" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-search w-6"
                style="color:var(--color-searching)"></i>Searching</a></label>
          <label class="flex items-center" data-topic-id="sorting"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#sorting" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-sort-amount-up-alt w-6"
                style="color:var(--color-sorting)"></i>Sorting</a></label>
          <label class="flex items-center" data-topic-id="recursion"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#recursion" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-undo-alt w-6"
                style="color:var(--color-recursion)"></i>Recursion</a></label>
          <label class="flex items-center" data-topic-id="backtracking"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#backtracking" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-shoe-prints w-6"
                style="color:var(--color-backtracking)"></i>Backtracking</a></label>
          <label class="flex items-center" data-topic-id="dp"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#dp" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-brain w-6"
                style="color:var(--color-dp)"></i>Dynamic Programming</a></label>
          <label class="flex items-center" data-topic-id="greedy"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#greedy" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-coins w-6"
                style="color:var(--color-greedy)"></i>Greedy Algorithms</a></label>
          <label class="flex items-center" data-topic-id="advancedtrees"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#advancedtrees" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-sitemap w-6"
                style="color:var(--color-advancedtrees)"></i>Advanced
              Trees</a></label>
          <label class="flex items-center" data-topic-id="dsu"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#dsu" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-object-group w-6"
                style="color:var(--color-dsu)"></i>Disjoint
              Set</a></label>
          <label class="flex items-center" data-topic-id="hashing"><input type="checkbox"
              class="progress-checkbox form-checkbox h-5 w-5 rounded text-indigo-500 bg-transparent border-gray-400 focus:ring-0"><a
              href="#hashing" class="sidebar-link ml-3 flex-1 p-2 rounded-md"><i class="fas fa-hashtag w-6"
                style="color:var(--color-hashing)"></i>Hashing</a>
          </label>

        </div>
      </aside>

      <main id="main-content" class="p-4 md:p-8 lg:p-12">
        <header class="mb-12">
          <h1 class="text-5xl font-extrabold mb-2">DSA Mastery Guide</h1>
          <p class="text-lg text-gray-500 dark:text-gray-400">Your ultimate guide to mastering Data Structures
            and Algorithms, from foundational concepts to advanced interview problems.</p>
        </header>
        <div class="space-y-16" id="sections-container">
          <section class="topic-section p-8 rounded-2xl" id="introduction" data-aos="fade-up"
            style="border-top-color: var(--color-introduction);">
            <h2 class="text-4xl font-bold flex items-center mb-4"><i class="fas fa-info-circle mr-4"
                style="color: var(--color-introduction);"></i>Introduction to DSA</h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">Welcome to the world of Data Structures
              and Algorithms (DSA)! Think of DSA as the fundamental toolkit for any programmer. Mastering
              these concepts is not just about passing interviews; it's about learning to write efficient,
              scalable, and elegant code.</p>

            <h3 class="text-2xl font-bold mb-3">What is Data?</h3>
            <p class="mb-4"><strong>Data</strong> is simply a collection of facts and figures. It can be a
              number, a character, a name, or an entire image. In computing, data is the raw material we
              work with.</p>

            <h3 class="text-2xl font-bold mb-3">What is a Data Structure?</h3>
            <p class="mb-4">A <strong>Data Structure</strong> is a particular way of organizing and storing
              data in a computer so that it can be accessed and modified efficiently. It's not just about
              storing data, but also about the relationships between data points.
              <br><br>
              Imagine a library. You could just throw all the books into a giant pile (a very inefficient
              structure!). Or, you could organize them by genre, then alphabetically by author. This
              organization is a data structure for books, making it easy to find what you're looking for.
            </p>

            <h3 class="text-2xl font-bold mb-3">What is an Algorithm?</h3>
            <p class="mb-4">An <strong>Algorithm</strong> is a step-by-step procedure or formula for solving
              a problem or accomplishing a task. Following our library analogy, the process you use to
              find a specific book (e.g., "Go to the 'Fiction' section, find the aisle for 'S', look for
              'Stephen King'") is an algorithm.</p>

            <h3 class="text-2xl font-bold mb-3">Types of Data Structures</h3>
            <div class="grid md:grid-cols-2 gap-6 mt-4">
              <div>
                <h4 class="font-bold text-lg mb-2">Linear Data Structures</h4>
                <p class="mb-2">Elements are arranged in a sequential order. Each element is connected
                  to its previous and next element.</p>
                <ul class="list-disc ml-5 space-y-1">
                  <li><strong>Arrays:</strong> A collection of items at contiguous memory locations.
                  </li>
                  <li><strong>Linked Lists:</strong> A collection of nodes where each node points to
                    the next.</li>
                  <li><strong>Stacks:</strong> A Last-In, First-Out (LIFO) structure.</li>
                  <li><strong>Queues:</strong> A First-In, First-Out (FIFO) structure.</li>
                </ul>
              </div>
              <div>
                <h4 class="font-bold text-lg mb-2">Non-Linear Data Structures</h4>
                <p class="mb-2">Elements are not arranged sequentially. An element can be connected to
                  multiple other elements.</p>
                <ul class="list-disc ml-5 space-y-1">
                  <li><strong>Trees:</strong> A hierarchical structure with a root node and child
                    nodes.</li>
                  <li><strong>Graphs:</strong> A collection of nodes (vertices) and edges connecting
                    them.</li>
                  <li><strong>Heaps:</strong> A specialized tree-based structure satisfying the heap
                    property.</li>
                  <li><strong>Hash Tables:</strong> A structure that maps keys to values for efficient
                    lookups.</li>
                </ul>
              </div>
            </div>
            <h3 class="text-2xl font-bold mt-12 mb-4">Why Does This Matter? The Power of Efficiency</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">The ultimate goal of DSA is to solve problems
              efficiently. The data structure you choose and the algorithm you apply can have a massive
              impact on your program's performance, especially as the amount of data grows.</p>

            <div class="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg mt-4 border-l-4 border-indigo-400">
              <h4 class="font-bold text-lg mb-2">A Real-World Example: Finding a Contact</h4>
              <ul class="list-disc ml-5 space-y-2 text-gray-700 dark:text-gray-300">
                <li><strong>Inefficient Way (Unsorted List):</strong> Imagine your contacts are written
                  on random scraps of paper thrown in a box. To find "David," you must look at every
                  single scrap of paper one by one until you find him. If you have 1,000 contacts,
                  this could take a long time.</li>
                <li><strong>Efficient Way (Sorted Array/Phone Book):</strong> Now imagine your contacts
                  are in a phone book, sorted alphabetically. To find "David," you can instantly open
                  to the 'D' section and quickly narrow down your search. This is dramatically faster.
                </li>
              </ul>
              <p class="mt-4 font-semibold">Choosing the right data structure (a sorted list) made the
                search algorithm vastly more efficient.</p>
            </div>
            <div class="mt-12 flex justify-between">
              <span></span>
              <a href="#complexity" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm">Next:
                Complexity <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
          </section>

          <section class="topic-section p-8 rounded-2xl" id="complexity" data-aos="fade-up"
            style="border-top-color: var(--color-complexity);">
            <h2 class="text-4xl font-bold flex items-center mb-4"><i class="fas fa-tachometer-alt mr-4"
                style="color: var(--color-complexity);"></i>Time & Space Complexity</h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">Why are some algorithms considered
              "better" than others? The answer often lies in their efficiency. We measure this efficiency
              using <strong>Time Complexity</strong> and <strong>Space Complexity</strong>. This analysis,
              often called Asymptotic Analysis, helps us predict how an algorithm will perform as the
              input size grows.</p>

            <h3 class="text-2xl font-bold mb-3">Time Complexity & Big O Notation</h3>
            <p class="mb-4"><strong>Time Complexity</strong> isn't about measuring the exact runtime in
              seconds. Instead, it describes how the number of operations an algorithm performs grows as
              the input size ($n$) increases. We express this using <strong>Big O Notation ($O$)</strong>,
              which describes the worst-case scenario.</p>

            <h4 class="text-xl font-bold mb-3">Common Big O Runtimes</h4>
            <p class="mb-4">Here are the most common complexities, from fastest to slowest growth rate:</p>
            <pre class="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg font-mono text-sm mb-6">
  $O(1)$      - Constant   -  Instantaneous. Example: Accessing an array element by index.
  $O(\log n)$  - Logarithmic-  Very fast. Scales well. Example: Binary search.
  $O(n)$      - Linear     -  Good. Time grows linearly with input. Example: Looping through an array.
  $O(n \log n)$- Log-Linear -  Efficient for sorting. Example: Merge Sort, Quick Sort.
  $O(n^2)$    - Quadratic  -  Slows down quickly. Example: Nested loops over the same input (Bubble Sort).
  $O(2^n)$    - Exponential-  Extremely slow. Often infeasible for large n. Example: Recursive Fibonacci.
  $O(n!)$    - Factorial  -  The slowest. Avoid at all costs. Example: Traveling Salesperson brute-force.
                        </pre>

            <h3 class="text-2xl font-bold mb-3">Space Complexity</h3>
            <p class="mb-4"><strong>Space Complexity</strong> measures the total amount of memory an
              algorithm needs to run, as a function of the input size ($n$). We are often most interested
              in the <strong>auxiliary space complexity</strong>, which is the extra space used by the
              algorithm, not including the space taken by the input itself.</p>
            <ul class="list-disc ml-5 space-y-2">
              <li>An algorithm that swaps two numbers in an array uses $O(1)$ auxiliary space (just a
                single `temp` variable).</li>
              <li>An algorithm that creates a copy of an array uses $O(n)$ auxiliary space because the new
                copy's size depends on the input size.</li>
            </ul>

            <div class="mt-12 flex justify-between">
              <a href="#introduction" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm"><i
                  class="fas fa-arrow-left mr-2"></i> Prev: Introduction</a>
              <a href="#arrays" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm">Next:
                Arrays <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
          </section>

          <section class="topic-section p-8 rounded-2xl" id="arrays" data-aos="fade-up"
            style="border-top-color: var(--color-arrays);">
            <h2 class="text-4xl font-bold flex items-center mb-4"><i class="fas fa-th-large mr-4"
                style="color: var(--color-arrays);"></i>Arrays</h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">An <strong>Array</strong> is the most
              fundamental data structure, serving as a building block for more complex structures. It's a
              collection of items stored at <strong>contiguous memory locations</strong>, meaning the
              items are physically next to each other in memory. This structure is what gives arrays their
              most powerful feature: $O(1)$ random access.</p>

            <h3 class="text-2xl font-bold mb-3">How Arrays Work in Memory</h3>
            <p class="mb-4">Because elements are stored side-by-side, the computer can calculate the exact
              memory address of any element using its index. The formula is simple: `address(arr[i]) =
              base_address + i * sizeof(element)`. This direct calculation is why accessing any element is
              instantaneous.</p>

            <pre class="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg text-center font-mono text-sm mb-6">
  Array: [ 10 | 20 | 30 | 40 ]
  Index:   0    1    2    3

Memory Address View (assuming 4 bytes per integer):
Address 0x1000: [ 10 ]  (Element at index 0)
Address 0x1004: [ 20 ]  (Element at index 1)
Address 0x1008: [ 30 ]  (Element at index 2)
Address 0x100C: [ 40 ]  (Element at index 3)
                        </pre>

            <details class="mb-6 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <summary>Pros & Cons</summary>
              <div class="grid md:grid-cols-2 gap-6 mt-4">
                <div>
                  <h4 class="font-bold text-lg mb-2 text-green-600">Pros</h4>
                  <ul class="list-disc ml-5 space-y-1">
                    <li><strong>Fast $O(1)$ Random Access:</strong> Direct access to any element
                      using
                      its index.</li>
                    <li><strong>Cache Friendly:</strong> Contiguous memory improves cache
                      performance.</li>
                    <li><strong>Memory Efficient:</strong> No overhead for pointers or metadata per
                      element.</li>
                  </ul>
                </div>
                <div>
                  <h4 class="font-bold text-lg mb-2 text-red-600">Cons</h4>
                  <ul class="list-disc ml-5 space-y-1">
                    <li><strong>Fixed Size:</strong> Cannot be easily resized. Requires creating a
                      new, larger array and copying elements.</li>
                    <li><strong>Slow $O(n)$ Insertion/Deletion:</strong> Adding or removing an
                      element
                      requires shifting all subsequent elements.</li>
                  </ul>
                </div>
              </div>
            </details>

            <h3 class="text-2xl font-bold mb-3">Visualizing Insertion Cost</h3>
            <p class="mb-4">Inserting `25` at index 2 requires shifting `30` and `40` one position to the
              right, an $O(n)$ operation in the worst case.</p>
            <pre class="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg font-mono text-sm mb-6">
1. Original: [ 10 | 20 | 30 | 40 | __ ]
               ^    ^    ^    ^
2. Shift 40: [ 10 | 20 | 30 | __ | 40 ]
               ^    ^    ^
3. Shift 30: [ 10 | 20 | __ | 30 | 40 ]
               ^    ^
4. Insert 25:[ 10 | 20 | 25 | 30 | 40 ]
</pre>

            <h3 class="text-2xl font-bold mt-8 mb-4">Example 1: Reverse an Array</h3>
            <div class="code-tabs mb-2">
              <button class="tab-btn active" data-tab="array-java">Java</button>
              <button class="tab-btn" data-tab="array-cpp">C++</button>
              <button class="tab-btn" data-tab="array-python">Python</button>
            </div>
            <div class="tab-content relative" id="array-java">
              <pre><code class="language-java">// Java: Reverse an Array (Two-Pointer)
int[] arr = {1, 2, 3, 4, 5};
int start = 0, end = arr.length - 1;
while (start < end) {
    int temp = arr[start];
    arr[start] = arr[end];
    arr[end] = temp;
    start++;
    end--;
}
// arr is now {5, 4, 3, 2, 1}</code></pre>
            </div>
            <div class="tab-content relative hidden" id="array-cpp">
              <pre><code class="language-cpp">// C++: Reverse an Array (using std::reverse)
#include <vector>
#include <algorithm>
std::vector<int> arr = {1, 2, 3, 4, 5};
std::reverse(arr.begin(), arr.end());
// arr is now {5, 4, 3, 2, 1}</code></pre>
            </div>
            <div class="tab-content relative hidden" id="array-python">
              <pre><code class="language-python"># Python: Reverse an Array (slicing)
arr = [1, 2, 3, 4, 5]
# Slicing creates a reversed copy
reversed_arr = arr[::-1] 
# To reverse in-place:
arr.reverse()
# arr is now [5, 4, 3, 2, 1]</code></pre>
            </div>

            <h3 class="text-2xl font-bold mt-8 mb-4">Example 2: Find Max & Min Element</h3>
            <div class="code-tabs mb-2">
              <button class="tab-btn active" data-tab="maxmin-java">Java</button>
              <button class="tab-btn" data-tab="maxmin-cpp">C++</button>
              <button class="tab-btn" data-tab="maxmin-python">Python</button>
            </div>
            <div class="tab-content relative" id="maxmin-java">
              <pre><code class="language-java">// Java: Find Max and Min
int[] arr = {10, 5, 42, 8, 15};
int min = arr[0];
int max = arr[0];
for (int i = 1; i < arr.length; i++) {
    if (arr[i] < min) min = arr[i];
    if (arr[i] > max) max = arr[i];
}
// min is 5, max is 42</code></pre>
            </div>
            <div class="tab-content relative hidden" id="maxmin-cpp">
              <pre><code class="language-cpp">// C++: Find Max and Min
#include <vector>
#include <algorithm> // For std::minmax_element
#include <iostream>

std::vector<int> arr = {10, 5, 42, 8, 15};
auto result = std::minmax_element(arr.begin(), arr.end());
std::cout << "Min: " << *result.first;  // Min: 5
std::cout << " Max: " << *result.second; // Max: 42</code></pre>
            </div>
            <div class="tab-content relative hidden" id="maxmin-python">
              <pre><code class="language-python"># Python: Find Max and Min
arr = [10, 5, 42, 8, 15]
min_val = min(arr)
max_val = max(arr)
# min_val is 5, max_val is 42</code></pre>
            </div>

            <details class="mt-8 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <summary class="text-xl">Top 5 Interview Questions</summary>
              <ul class="list-decimal ml-5 space-y-4 mt-4">
                <li>
                  <a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Two Sum</a> - <span
                    class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given an array of integers and a target, return indices of the two numbers that
                    add up to the target. <br><strong>Core Idea:</strong> Use a hash map to store
                    numbers you've seen and their indices. For each new number, check if `target -
                    number` exists in the map.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Best Time to Buy and
                    Sell
                    Stock</a> - <span
                    class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Find the maximum profit you can achieve by buying a stock on one day and selling
                    it on a later day. <br><strong>Core Idea:</strong> Iterate through the array,
                    keeping track of the minimum price seen so far and the maximum profit
                    calculated.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Maximum Subarray (Kadane's
                    Algorithm)</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Find the contiguous subarray with the largest sum. <br><strong>Core
                      Idea:</strong> Iterate through the array, maintaining a `current_max` and a
                    `global_max`. If `current_max` becomes negative, reset it to the current
                    element.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Product of Array
                    Except
                    Self</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given an array, return an answer array where `answer[i]` is the product of all
                    elements except `nums[i]`, without using division. <br><strong>Core
                      Idea:</strong> Use two passes. First, calculate prefix products. Second,
                    calculate postfix products and multiply them with the prefix products.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Rotate Array</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Rotate the array to the right by k steps. <br><strong>Core Idea:</strong> A
                    clever $O(1)$ space approach is to reverse the entire array, then reverse the
                    first k elements, and finally reverse the remaining n-k elements.</p>
                </li>
              </ul>
            </details>

            <div class="mt-12 flex justify-between">
              <a href="#complexity" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm"><i
                  class="fas fa-arrow-left mr-2"></i> Prev: Complexity</a>
              <a href="#linkedlists" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm">Next:
                Linked Lists <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
          </section>
          <section class="topic-section p-8 rounded-2xl" id="linkedlists" data-aos="fade-up"
            style="border-top-color: var(--color-linkedlists);">
            <h2 class="text-4xl font-bold flex items-center mb-4">
              <i class="fas fa-link mr-4" style="color: var(--color-linkedlists);"></i>Linked Lists: An
              In-Depth Guide
            </h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">
              Linked lists are one of the most fundamental dynamic data structures. Unlike arrays that
              rely on a rigid, contiguous block of memory, linked lists are built on a flexible chain of
              nodes scattered across memory, connected only by pointers. Mastering their mechanics is
              crucial for any serious programmer.
            </p>

            <h3 class="text-2xl font-bold mb-3">The Anatomy of a Linked List</h3>
            <p class="mb-4">
              A linked list is defined by two core components: the <strong>Node</strong> and the
              <strong>List</strong> itself, which manages the nodes.
            </p>
            <div class="space-y-6">
              <div>
                <h4 class="text-xl font-semibold">1. The Node: The Building Block</h4>
                <p>A node is a self-referential object, meaning it holds a reference to another object
                  of its own type. It contains two essential pieces of information:</p>
                <ul class="list-disc ml-5 mt-2 space-y-1">
                  <li><strong>Data:</strong> The value stored in the node.</li>
                  <li><strong>Pointer(s):</strong> At least one reference (pointer) to another node.
                  </li>
                </ul>
                <p class="mt-2">The last node's pointer always points to <strong>null</strong>,
                  signifying the end of the chain.</p>
              </div>
              <div>
                <h4 class="text-xl font-semibold">2. The List: The Manager</h4>
                <p>The LinkedList class itself is surprisingly simple. At a minimum, it only needs to
                  keep track of one thing: the <strong>Head</strong>, which is the very first node in
                  the list. For efficiency, it's common to also store:</p>
                <ul class="list-disc ml-5 mt-2 space-y-1">
                  <li><strong>Tail:</strong> A pointer to the last node, allowing for $O(1)$
                    insertions at the end.</li>
                  <li><strong>Size/Length:</strong> A counter that is updated on every
                    insertion/deletion, providing the list's size in $O(1)$ time.</li>
                </ul>
              </div>
              <div>
                <h4 class="text-xl font-semibold">3. Memory Allocation: Heap vs. Stack</h4>
                <p>This is a key difference from arrays. Static arrays are typically allocated on the
                  <strong>stack</strong> in a single, continuous block. In contrast, each node in a
                  linked list is dynamically allocated on the <strong>heap</strong>. This means nodes
                  can exist anywhere in memory, providing flexibility at the cost of the direct-access
                  capability that contiguous memory gives arrays.
                </p>
              </div>
            </div>

            <h3 class="text-2xl font-bold mt-8 mb-4">Core Operations In-Depth</h3>
            <ul class="list-disc ml-5 space-y-3">
              <li><strong>Traversal ($O(n)$):</strong> To access any element, you must start from the
                `head` and follow each `next` pointer until you reach the desired node. This is why
                random access is slow.</li>
              <li><strong>Insertion at Start ($O(1)$):</strong> Create a new node, point its `next` to the
                current `head`, and then update the list's `head` to be the new node. This is extremely
                fast.</li>
              <li><strong>Insertion at End ($O(1)$ with tail pointer, $O(n)$ without):</strong> If you
                track the `tail` node, you just point the current `tail.next` to the new node and update
                `tail`. Without a `tail` pointer, you must traverse the entire list to find the last
                node.</li>
              <li><strong>Deletion ($O(n)$):</strong> To delete a node, you must first traverse the list
                to find the node *before* the one you want to delete. Then, you re-wire the previous
                node's `next` pointer to skip over the target node, effectively removing it from the
                chain.</li>
            </ul>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-8 mb-4">Types of Linked Lists & Code Implementations</h3>

            <div class="topic-section p-6 rounded-xl border-t-4" style="border-top-color: var(--color-linkedlists)">
              <h4 class="text-2xl font-bold mb-3">1. Singly Linked List</h4>
              <p class="mb-4">The standard, most basic form. Each node contains data and a single pointer
                to the next node in the sequence. Traversal is only possible in the forward direction.
              </p>

              <div class="code-tabs mb-2">
                <button class="tab-btn active" data-tab="sll-java">Java</button>
                <button class="tab-btn" data-tab="sll-cpp">C++</button>
                <button class="tab-btn" data-tab="sll-python">Python</button>
              </div>
              <div class="tab-content relative" id="sll-java">
                <pre><code class="language-java">// Singly Linked List in Java
class SLLNode {
    int data;
    SLLNode next;
    public SLLNode(int data) { this.data = data; this.next = null; }
}

class SinglyLinkedList {
    SLLNode head;
    
    public void append(int data) {
        if (head == null) { head = new SLLNode(data); return; }
        SLLNode current = head;
        while (current.next != null) { current = current.next; }
        current.next = new SLLNode(data);
    }

    public void prepend(int data) {
        SLLNode newHead = new SLLNode(data);
        newHead.next = head;
        head = newHead;
    }

    public void deleteWithValue(int data) {
        if (head == null) return;
        if (head.data == data) { head = head.next; return; }
        SLLNode current = head;
        while (current.next != null) {
            if (current.next.data == data) {
                current.next = current.next.next;
                return;
            }
            current = current.next;
        }
    }
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="sll-cpp">
                <pre><code class="language-cpp">// Singly Linked List in C++
#include <iostream>

class SLLNode {
public:
    int data;
    SLLNode* next;
    SLLNode(int val) : data(val), next(nullptr) {}
};

class SinglyLinkedList {
public:
    SLLNode* head;
    SinglyLinkedList() : head(nullptr) {}

    void append(int data) {
        SLLNode* newNode = new SLLNode(data);
        if (head == nullptr) { head = newNode; return; }
        SLLNode* current = head;
        while (current->next != nullptr) { current = current->next; }
        current->next = newNode;
    }

    void prepend(int data) {
        SLLNode* newHead = new SLLNode(data);
        newHead->next = head;
        head = newHead;
    }
    
    void deleteWithValue(int data) {
        if (head == nullptr) return;
        if (head->data == data) { head = head->next; return; }
        SLLNode* current = head;
        while (current->next != nullptr && current->next->data != data) {
            current = current->next;
        }
        if (current->next != nullptr) {
            current->next = current->next->next;
        }
    }
};</code></pre>
              </div>
              <div class="tab-content relative hidden" id="sll-python">
                <pre><code class="language-python"># Singly Linked List in Python
class SLLNode:
    def __init__(self, data=None):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = SLLNode(data)
        if self.head is None:
            self.head = new_node
            return
        last_node = self.head
        while last_node.next:
            last_node = last_node.next
        last_node.next = new_node

    def prepend(self, data):
        new_node = SLLNode(data)
        new_node.next = self.head
        self.head = new_node

    def delete_with_value(self, data):
        if self.head is None:
            return
        if self.head.data == data:
            self.head = self.head.next
            return
        current_node = self.head
        while current_node.next and current_node.next.data != data:
            current_node = current_node.next
        if current_node.next:
            current_node.next = current_node.next.next
</code></pre>
              </div>
            </div>

            <div class="topic-section p-6 rounded-xl border-t-4 mt-8"
              style="border-top-color: var(--color-linkedlists)">
              <h4 class="text-2xl font-bold mb-3">2. Doubly Linked List</h4>
              <p class="mb-4">An enhanced version where each node has two pointers: one to the `next` node
                and one to the `previous` node. This allows for traversal in both directions, making
                operations like deletion and reverse traversal much more efficient.</p>

              <div class="code-tabs mb-2">
                <button class="tab-btn active" data-tab="dll-java">Java</button>
                <button class="tab-btn" data-tab="dll-cpp">C++</button>
                <button class="tab-btn" data-tab="dll-python">Python</button>
              </div>
              <div class="tab-content relative" id="dll-java">
                <pre><code class="language-java">// Doubly Linked List in Java
class DLLNode {
    int data;
    DLLNode prev, next;
    public DLLNode(int data) { this.data = data; this.prev = null; this.next = null; }
}

class DoublyLinkedList {
    DLLNode head;
    
    public void append(int data) {
        DLLNode newNode = new DLLNode(data);
        if (head == null) { head = newNode; return; }
        DLLNode current = head;
        while (current.next != null) { current = current.next; }
        current.next = newNode;
        newNode.prev = current;
    }

    public void deleteWithValue(int data) {
        DLLNode current = head;
        while (current != null) {
            if (current.data == data) {
                if (current.prev != null) current.prev.next = current.next;
                else head = current.next;
                
                if (current.next != null) current.next.prev = current.prev;
                return;
            }
            current = current.next;
        }
    }
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="dll-cpp">
                <pre><code class="language-cpp">// Doubly Linked List in C++
#include <iostream>

class DLLNode {
public:
    int data;
    DLLNode *prev, *next;
    DLLNode(int val) : data(val), prev(nullptr), next(nullptr) {}
};

class DoublyLinkedList {
public:
    DLLNode* head;
    DoublyLinkedList() : head(nullptr) {}

    void append(int data) {
        DLLNode* newNode = new DLLNode(data);
        if (head == nullptr) { head = newNode; return; }
        DLLNode* current = head;
        while (current->next != nullptr) { current = current->next; }
        current->next = newNode;
        newNode->prev = current;
    }
    
    void deleteWithValue(int data) {
        DLLNode* current = head;
        while (current != nullptr) {
            if (current->data == data) {
                if (current->prev != nullptr) current->prev->next = current->next;
                else head = current->next;

                if (current->next != nullptr) current->next->prev = current->prev;
                delete current; // Free memory
                return;
            }
            current = current->next;
        }
    }
};</code></pre>
              </div>
              <div class="tab-content relative hidden" id="dll-python">
                <pre><code class="language-python"># Doubly Linked List in Python
class DLLNode:
    def __init__(self, data=None):
        self.data = data
        self.next = None
        self.prev = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = DLLNode(data)
        if self.head is None:
            self.head = new_node
            return
        last_node = self.head
        while last_node.next:
            last_node = last_node.next
        last_node.next = new_node
        new_node.prev = last_node

    def delete_with_value(self, data):
        current_node = self.head
        while current_node:
            if current_node.data == data:
                if current_node.prev:
                    current_node.prev.next = current_node.next
                else: # It's the head
                    self.head = current_node.next
                
                if current_node.next:
                    current_node.next.prev = current_node.prev
                return
            current_node = current_node.next
</code></pre>
              </div>
            </div>

            <div class="topic-section p-6 rounded-xl border-t-4 mt-8"
              style="border-top-color: var(--color-linkedlists)">
              <h4 class="text-2xl font-bold mb-3">3. Circular Linked List</h4>
              <p class="mb-4">In this variation, the `next` pointer of the last node (the tail) points
                back to the `head` node instead of `null`. This creates a continuous loop, useful for
                applications that need to cycle through items, like a slideshow or a round-robin
                scheduling algorithm.</p>

              <div class="code-tabs mb-2">
                <button class="tab-btn active" data-tab="cll-java">Java</button>
                <button class="tab-btn" data-tab="cll-cpp">C++</button>
                <button class="tab-btn" data-tab="cll-python">Python</button>
              </div>
              <div class="tab-content relative" id="cll-java">
                <pre><code class="language-java">// Circular Singly Linked List in Java
class CLLNode {
    int data;
    CLLNode next;
    public CLLNode(int data) { this.data = data; }
}

class CircularLinkedList {
    CLLNode head = null;
    CLLNode tail = null;

    public void append(int data) {
        CLLNode newNode = new CLLNode(data);
        if (head == null) {
            head = newNode;
        } else {
            tail.next = newNode;
        }
        tail = newNode;
        tail.next = head; // Loop back to head
    }

    public void display() { // Must be careful to avoid infinite loop
        CLLNode current = head;
        if (head != null) {
            do {
                System.out.print(current.data + " -> ");
                current = current.next;
            } while (current != head);
        }
        System.out.println(" (Head)");
    }
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="cll-cpp">
                <pre><code class="language-cpp">// Circular Singly Linked List in C++
#include <iostream>

class CLLNode {
public:
    int data;
    CLLNode* next;
    CLLNode(int val) : data(val), next(nullptr) {}
};

class CircularLinkedList {
public:
    CLLNode* head;
    CircularLinkedList() : head(nullptr) {}

    void append(int data) {
        CLLNode* newNode = new CLLNode(data);
        if (head == nullptr) {
            head = newNode;
            newNode->next = head;
            return;
        }
        CLLNode* tail = head;
        while (tail->next != head) {
            tail = tail->next;
        }
        tail->next = newNode;
        newNode->next = head;
    }
};</code></pre>
              </div>
              <div class="tab-content relative hidden" id="cll-python">
                <pre><code class="language-python"># Circular Singly Linked List in Python
class CLLNode:
    def __init__(self, data=None):
        self.data = data
        self.next = None

class CircularLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = CLLNode(data)
        if not self.head:
            self.head = new_node
            new_node.next = self.head
            return
        
        current = self.head
        while current.next != self.head:
            current = current.next
        current.next = new_node
        new_node.next = self.head
</code></pre>
              </div>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-8 mb-4">Top 5 Interview Questions</h3>
            <details class="mt-8 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <summary class="text-xl">View Essential Linked List Interview Questions</summary>
              <ul class="list-decimal ml-5 space-y-4 mt-4">
                <li>
                  <a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Reverse a Linked List</a>
                  - <span class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given the head of a singly linked list, reverse it and return the new head.
                    <br><strong>Core Idea:</strong> Use three pointers (`prev`, `current`, `next`)
                    to iterate through the list, reversing the direction of the `next` pointer for
                    each node.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Linked List Cycle (Floyd's
                    Tortoise and Hare)</a> - <span
                    class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Determine if a linked list has a cycle in it. <br><strong>Core Idea:</strong>
                    Use two pointers, a "slow" one that moves one step at a time, and a "fast" one
                    that moves two steps. If there's a cycle, the fast pointer will eventually lap
                    the slow pointer and they will meet.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Merge Two Sorted
                    Lists</a>
                  - <span class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Merge two sorted linked lists into a single, sorted linked list.
                    <br><strong>Core Idea:</strong> Use a dummy head node for the new list. Compare
                    the nodes from both input lists and append the smaller one to the new list,
                    advancing the pointer of the list from which the node was taken.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Remove Nth Node From
                    End
                    of List</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given a list and an integer `n`, remove the nth node from the end of the list.
                    <br><strong>Core Idea:</strong> Use a two-pointer "gap" method. Move a "fast"
                    pointer `n` steps ahead. Then, move both a "fast" and a "slow" pointer one step
                    at a time. When the fast pointer reaches the end, the slow pointer will be at
                    the node just before the one to be deleted.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/middle-of-the-linked-list/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Find the Middle of
                    the
                    Linked List</a> - <span
                    class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Find the middle node of a singly linked list. <br><strong>Core Idea:</strong>
                    Another application of the fast/slow pointer technique. When the fast pointer
                    (moving two steps) reaches the end of the list, the slow pointer (moving one
                    step) will be at the middle.</p>
                </li>
              </ul>
            </details>

            <div class="mt-12 flex justify-between">
              <a href="#arrays" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm"><i
                  class="fas fa-arrow-left mr-2"></i> Prev: Arrays</a>
              <a href="#stacks" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm">Next:
                Stacks <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
          </section>

          <section class="topic-section p-8 rounded-2xl" id="stacks" data-aos="fade-up"
            style="border-top-color: var(--color-stacks);">
            <h2 class="text-4xl font-bold flex items-center mb-4">
              <i class="fas fa-layer-group mr-4" style="color: var(--color-stacks);"></i>Stacks: An
              In-Depth Guide
            </h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">
              The Stack is one of the simplest yet most powerful data structures. Its defining feature is
              a strict rule about how you access data. Think of a stack of plates, a can of Pringles, or a
              Pez dispenser: you can only add to or remove from the **top**. This simple constraint makes
              stacks incredibly useful for solving a specific class of problems.
            </p>

            <h3 class="text-2xl font-bold mb-3">The Core Principle: LIFO</h3>
            <p class="mb-4">
              A stack operates on a **LIFO (Last-In, First-Out)** principle. This means the very last item
              you add to the stack is the very first item you can take out. The plate you just placed on
              top of the stack is the first one you'll grab for dinner.
            </p>

            <h3 class="text-2xl font-bold mt-8 mb-4">The Core Operations (The "Stack API")</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              A stack is an Abstract Data Type (ADT), defined by its behavior, not its implementation. All
              core operations are incredibly fast, taking constant time—<strong>$O(1)$</strong>.
            </p>
            <ul class="list-disc ml-5 space-y-3 mb-6">
              <li><strong>Push:</strong> Adds an element to the top of the stack.</li>
              <li><strong>Pop:</strong> Removes and returns the element from the top of the stack.</li>
              <li><strong>Peek (or Top):</strong> Returns the element at the top of the stack *without*
                removing it.</li>
              <li><strong>isEmpty:</strong> Returns `true` if the stack contains no elements.</li>
            </ul>

            <h3 class="text-2xl font-bold mt-8 mb-4">How to Build a Stack</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              Because a stack is a concept, we need an underlying data structure to build it. The two most
              common choices are arrays and linked lists.
            </p>
            <div class="grid md:grid-cols-2 gap-8 mt-4">
              <div>
                <h4 class="font-bold text-lg mb-2">1. Implementation with an Array (or Dynamic Array)
                </h4>
                <p>This is the most common method. An array stores the data, and a variable (e.g., an
                  index called `top`) keeps track of the stack's top.
                  <br><strong>Pros:</strong> Excellent performance due to contiguous memory
                  (cache-friendly) and no overhead for pointers.
                  <br><strong>Cons:</strong> A basic array has a fixed size. A dynamic array (like
                  Java's `ArrayList` or C++'s `std::vector`) can resize, but this is an occasional
                  $O(n)$ operation.
                </p>
              </div>
              <div>
                <h4 class="font-bold text-lg mb-2">2. Implementation with a Linked List</h4>
                <p>The `head` of the linked list serves as the `top` of the stack. A `push` operation
                  prepends a new node to the list, and a `pop` operation removes the head.
                  <br><strong>Pros:</strong> Truly dynamic size with no expensive resizing operations.
                  <br><strong>Cons:</strong> Uses slightly more memory per element (for the pointer)
                  and can be less cache-friendly.
                </p>
              </div>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-8 mb-4">Stack Code Implementation (Using Dynamic Array/List)
            </h3>
            <div class="code-tabs mb-2">
              <button class="tab-btn active" data-tab="stack-java">Java</button>
              <button class="tab-btn" data-tab="stack-cpp">C++</button>
              <button class="tab-btn" data-tab="stack-python">Python</button>
            </div>
            <div class="tab-content relative" id="stack-java">
              <pre><code class="language-java">// Stack in Java (using built-in Deque for simplicity)
import java.util.ArrayDeque;
import java.util.Deque;

class StackExample {
    public static void main(String[] args) {
        // Deque is the recommended interface for stack operations
        Deque<Integer> stack = new ArrayDeque<>();

        stack.push(10); // Push
        stack.push(20);
        stack.push(30);

        System.out.println("Top element is: " + stack.peek()); // Peek: 30

        int popped = stack.pop(); // Pop
        System.out.println("Popped element: " + popped); // Popped: 30
        
        System.out.println("Is stack empty? " + stack.isEmpty()); // isEmpty: false
    }
}
</code></pre>
            </div>
            <div class="tab-content relative hidden" id="stack-cpp">
              <pre><code class="language-cpp">// Stack in C++ (using std::stack)
#include <iostream>
#include <stack>

int main() {
    std::stack<int> s;

    s.push(10); // Push
    s.push(20);
    s.push(30);

    std::cout << "Top element is: " << s.top() << std::endl; // Top (Peek): 30

    s.pop(); // Pop
    
    std::cout << "Is stack empty? " << (s.empty() ? "Yes" : "No") << std::endl; // empty (isEmpty): No

    return 0;
}
</code></pre>
            </div>
            <div class="tab-content relative hidden" id="stack-python">
              <pre><code class="language-python"># Stack in Python (using built-in list)
# Python's list makes a great stack as append() and pop() are O(1)
stack = []

# Push
stack.append(10)
stack.append(20)
stack.append(30)

# Peek (Top)
# Note: Accessing the last element is stack[-1]
print(f"Top element is: {stack[-1]}")

# Pop
popped_element = stack.pop()
print(f"Popped element: {popped_element}")

# isEmpty (check if list is empty)
is_empty = not stack
print(f"Is stack empty? {is_empty}")
</code></pre>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-8 mb-4">Where Stacks Shine: Common Use Cases</h3>
            <ul class="list-disc ml-5 space-y-3">
              <li><strong>Function Call Management:</strong> This is the most famous use! When a function
                is called, it's pushed onto the "call stack." When it returns, it's popped off.
                Recursion is possible because of this stack. A "stack overflow" error means this stack
                has run out of space.</li>
              <li><strong>Undo/Redo Functionality:</strong> In a text editor, each action you take is
                pushed onto an "undo" stack. When you hit Ctrl+Z, the action is popped.</li>
              <li><strong>Syntax Parsing:</strong> Compilers use stacks to check if parentheses, brackets,
                and braces are correctly balanced in your code.</li>
              <li><strong>Backtracking Algorithms:</strong> A stack is perfect for solving problems like
                maze navigation. You push your current path onto the stack. If you hit a dead end, you
                pop from the stack to backtrack to a previous point.</li>
            </ul>

            <h3 class="text-2xl font-bold mt-12 mb-4">Top 5 Interview Questions</h3>
            <details class="mt-8 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <summary class="text-xl">View Essential Stack Interview Questions</summary>
              <ul class="list-decimal ml-5 space-y-4 mt-4">
                <li>
                  <a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Valid Parentheses</a> -
                  <span class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Check if a string of brackets `()[]{}` is correctly matched and balanced.
                    <br><strong>Core Idea:</strong> When you see an opening bracket, push it onto
                    the stack. When you see a closing bracket, check if the stack is empty or if the
                    top of the stack is the matching opening bracket. If it is, pop. If not, the
                    string is invalid.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Min Stack</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Design a stack that supports push, pop, top, and retrieving the minimum element
                    in constant time. <br><strong>Core Idea:</strong> Use two stacks: one for the
                    actual data and a second "min stack" that only stores the minimum value seen so
                    far. When you push a new value, if it's less than or equal to the top of the min
                    stack, push it there too.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Evaluate Reverse
                    Polish
                    Notation</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Evaluate the value of an arithmetic expression in Reverse Polish Notation (e.g.,
                    `["2", "1", "+", "3", "*"]`). <br><strong>Core Idea:</strong> Iterate through
                    the tokens. If a token is a number, push it onto the stack. If it's an operator,
                    pop the top two numbers, perform the operation, and push the result back onto
                    the stack.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/implement-queue-using-stacks/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Implement Queue
                    using
                    Stacks</a> - <span
                    class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Implement a FIFO queue using only two LIFO stacks. <br><strong>Core
                      Idea:</strong> Use one stack (`s1`) for `push` operations. For `pop` or
                    `peek`, if the second stack (`s2`) is empty, move all elements from `s1` to
                    `s2`. This reverses their order, effectively making the top of `s2` the front of
                    the queue.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/daily-temperatures/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Daily Temperatures</a> -
                  <span class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given a list of daily temperatures, find how many days you have to wait until a
                    warmer temperature. <br><strong>Core Idea:</strong> Use a "monotonic stack" that
                    stores indices of days with decreasing temperatures. When you encounter a warmer
                    day, you can pop from the stack and calculate the waiting days for all the
                    previous, cooler days.</p>
                </li>
              </ul>
            </details>

            <div class="mt-12 flex justify-between">
              <a href="#linkedlists" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm"><i
                  class="fas fa-arrow-left mr-2"></i> Prev: Linked Lists</a>
              <a href="#queues" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm">Next:
                Queues <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
          </section>

          <section class="topic-section p-8 rounded-2xl" id="queues" data-aos="fade-up"
            style="border-top-color: var(--color-queues);">
            <h2 class="text-4xl font-bold flex items-center mb-4">
              <i class="fas fa-stream mr-4" style="color: var(--color-queues);"></i>Queues: An In-Depth
              Guide
            </h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">
              Where a Stack is like a pile of plates, a **Queue** is a **real-life line**. Think of people
              waiting for a bus, tasks sent to a printer, or orders in a system. The principle is one of
              fairness: the first one to arrive is the first one to be served. This makes queues essential
              for managing tasks and resources in an orderly fashion.
            </p>

            <h3 class="text-2xl font-bold mb-3">The Core Principle: FIFO</h3>
            <p class="mb-4">
              A queue operates on a **FIFO (First-In, First-Out)** principle. This is the direct opposite
              of a stack. The first element added to the queue will be the first element to be removed.
              The first person who gets in line is the first person who gets on the bus.
            </p>

            <h3 class="text-2xl font-bold mt-8 mb-4">The Core Operations (The "Queue API")</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              Like a stack, a Queue is an Abstract Data Type (ADT). In a proper implementation (typically
              with a linked list), all of its core operations take constant time—<strong>$O(1)$</strong>.
            </p>
            <ul class="list-disc ml-5 space-y-3 mb-6">
              <li><strong>Enqueue (or Add):</strong> Adds an element to the **back (tail)** of the queue.
              </li>
              <li><strong>Dequeue (or Remove):</strong> Removes and returns the element from the **front
                (head)** of the queue.</li>
              <li><strong>Peek (or Front):</strong> Returns the element at the front of the queue
                *without* removing it.</li>
              <li><strong>isEmpty:</strong> Returns `true` if the queue is empty.</li>
            </ul>

            <h3 class="text-2xl font-bold mt-8 mb-4">How to Build a Queue</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              Queues are typically built using one of two underlying structures.
            </p>
            <div class="grid md:grid-cols-2 gap-8 mt-4">
              <div>
                <h4 class="font-bold text-lg mb-2">1. Implementation with a Linked List</h4>
                <p>This is the most natural and efficient way. By keeping pointers to both the `head`
                  and `tail` of the list, we can achieve $O(1)$ performance for both adding to the
                  tail (enqueue) and removing from the head (dequeue).
                  <br><strong>Pros:</strong> Guaranteed $O(1)$ enqueue and dequeue, and a truly
                  dynamic size.
                  <br><strong>Cons:</strong> Standard linked list overhead (extra memory for
                  pointers).
                </p>
              </div>
              <div>
                <h4 class="font-bold text-lg mb-2">2. Implementation with an Array (Circular Queue)</h4>
                <p>A simple array is inefficient for a queue, as removing from the front requires
                  shifting all elements ($O(n)$). To solve this, a **circular array** is used, where
                  the back of the array wraps around to the front. Two pointers, `front` and `rear`,
                  track the start and end of the queue.
                  <br><strong>Pros:</strong> Very memory-efficient and cache-friendly.
                  <br><strong>Cons:</strong> Can have a fixed size, and the "wrap-around" logic is
                  more complex to implement correctly.
                </p>
              </div>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-8 mb-4">Queue Code Implementation (Using a Linked List)</h3>
            <div class="code-tabs mb-2">
              <button class="tab-btn active" data-tab="queue-java">Java</button>
              <button class="tab-btn" data-tab="queue-cpp">C++</button>
              <button class="tab-btn" data-tab="queue-python">Python</button>
            </div>
            <div class="tab-content relative" id="queue-java">
              <pre><code class="language-java">// Queue in Java (using built-in LinkedList)
import java.util.LinkedList;
import java.util.Queue;

class QueueExample {
    public static void main(String[] args) {
        // LinkedList implements the Queue interface
        Queue<String> queue = new LinkedList<>();

        // Enqueue
        queue.add("Job 1");
        queue.add("Job 2");
        queue.add("Job 3");

        // Peek
        System.out.println("Next to process: " + queue.peek()); // "Job 1"

        // Dequeue
        String processed = queue.remove();
        System.out.println("Processed: " + processed); // "Job 1"
        
        System.out.println("Is queue empty? " + queue.isEmpty()); // false
    }
}
</code></pre>
            </div>
            <div class="tab-content relative hidden" id="queue-cpp">
              <pre><code class="language-cpp">// Queue in C++ (using std::queue)
#include <iostream>
#include <queue>
#include <string>

int main() {
    std::queue<std::string> q;

    // Enqueue
    q.push("Job 1");
    q.push("Job 2");
    q.push("Job 3");

    // Peek (front)
    std::cout << "Next to process: " << q.front() << std::endl;

    // Dequeue
    q.pop();
    
    std::cout << "Is queue empty? " << (q.empty() ? "Yes" : "No") << std::endl;

    return 0;
}
</code></pre>
            </div>
            <div class="tab-content relative hidden" id="queue-python">
              <pre><code class="language-python"># Queue in Python (using collections.deque)
from collections import deque

# deque is a double-ended queue, optimized for appends and pops from both ends
queue = deque()

# Enqueue (append to the right)
queue.append("Job 1")
queue.append("Job 2")
queue.append("Job 3")

# Peek (access the leftmost element)
print(f"Next to process: {queue[0]}")

# Dequeue (pop from the left)
processed = queue.popleft()
print(f"Processed: {processed}")

# isEmpty (check if deque has items)
is_empty = not queue
print(f"Is queue empty? {is_empty}")
</code></pre>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-8 mb-4">Where Queues Organize Chaos</h3>
            <ul class="list-disc ml-5 space-y-3">
              <li><strong>Operating Systems:</strong> CPU task scheduling, printer queues, and handling
                system interrupts are all managed with queues to ensure tasks are processed in a fair,
                first-come, first-served manner.</li>
              <li><strong>Networking:</strong> Data packets are placed in a queue (a buffer) as they
                arrive, waiting to be processed. This handles network congestion and ensures data
                integrity.</li>
              <li><strong>Breadth-First Search (BFS):</strong> This is a crucial algorithm for traversing
                trees and graphs. A queue is used to keep track of the nodes to visit next, ensuring the
                graph is explored level by level.</li>
              <li><strong>Resource Sharing:</strong> When multiple processes need access to a single
                shared resource, requests are placed in a queue to grant access one by one.</li>
            </ul>

            <h3 class="text-2xl font-bold mt-12 mb-4">Top 5 Interview Questions</h3>
            <details class="mt-8 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <summary class="text-xl">View Essential Queue Interview Questions</summary>
              <ul class="list-decimal ml-5 space-y-4 mt-4">
                <li>
                  <a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Implement Stack
                    using
                    Queues</a> - <span
                    class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Implement a LIFO stack using only two FIFO queues. <br><strong>Core
                      Idea:</strong> To simulate a `push`, add the new element to one queue, then
                    move all elements from the second queue to the first. To `pop`, simply dequeue
                    from the non-empty queue. A more efficient push approach involves just adding to
                    a queue and for pop, moving n-1 elements to the other queue.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Binary Tree Level
                    Order
                    Traversal</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given a binary tree, return the level-by-level traversal of its nodes' values.
                    <br><strong>Core Idea:</strong> This is the canonical use case for a queue in
                    tree algorithms (Breadth-First Search). Start by adding the root to a queue.
                    Then, loop while the queue is not empty: dequeue a node, process its value, and
                    enqueue its children.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Number of Islands</a> -
                  <span class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given a 2D grid of '1's (land) and '0's (water), count the number of islands.
                    <br><strong>Core Idea:</strong> Iterate through the grid. When you find a '1',
                    increment your island count and start a Breadth-First Search (BFS) from that
                    cell. Use a queue to explore all connected '1's, marking them as visited (e.g.,
                    changing to '0') so you don't count them again.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/moving-average-from-data-stream/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Moving Average from
                    Data
                    Stream</a> - <span
                    class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Design a class to calculate the moving average of the last `k` numbers in a
                    stream. <br><strong>Core Idea:</strong> Use a queue to maintain a "sliding
                    window" of the last `k` numbers. When a new number arrives, add it to the queue
                    (enqueue). If the queue size exceeds `k`, remove the oldest number (dequeue).
                    The average is the sum of the numbers in the queue divided by its size.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/design-circular-queue/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Design Circular
                    Queue</a>
                  - <span class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Implement the Circular Queue data structure. <br><strong>Core Idea:</strong> Use
                    a fixed-size array and two pointers, `head` and `tail`. The key challenge is
                    handling the wrap-around logic using the modulo operator (`%`) to calculate the
                    next index for `tail` and `head`.</p>
                </li>
              </ul>
            </details>

            <div class="mt-12 flex justify-between">
              <a href="#stacks" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm"><i
                  class="fas fa-arrow-left mr-2"></i> Prev: Stacks</a>
              <a href="#trees" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm">Next: Trees
                <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
          </section>

          <section class="topic-section p-8 rounded-2xl" id="trees" data-aos="fade-up"
            style="border-top-color: var(--color-trees);">
            <h2 class="text-4xl font-bold flex items-center mb-4">
              <i class="fas fa-tree mr-4" style="color: var(--color-trees);"></i>Trees: An In-Depth Guide
              to Hierarchies
            </h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">
              We now move from linear data structures to hierarchical ones. A Tree represents data that
              has a parent-child relationship. Think of a computer's file system (a folder can contain
              other folders and files), an organization chart, or a family tree. They are one of the most
              powerful and versatile data structures, enabling immense efficiency in searching and
              organizing data.
            </p>

            <h3 class="text-2xl font-bold mb-3">Focusing on the Foundation: The Binary Search Tree (BST)
            </h3>
            <p class="mb-4">
              The most common and fundamental type of tree is the **Binary Search Tree (BST)**. It's
              called "binary" because each node can have at most **two** children: a left child and a
              right child. It's a "search" tree because it's organized by a strict rule that makes
              searching incredibly fast.
            </p>

            <div class="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg my-6 border-l-4 border-green-500">
              <h4 class="font-bold text-lg mb-2">The Golden Rule of BSTs: The BST Property</h4>
              <p class="text-gray-700 dark:text-gray-300">
                For any given node in the tree:
              </p>
              <ul class="list-disc ml-5 mt-2 space-y-1">
                <li>All values in its **left subtree** must be **less than** the node's own value.</li>
                <li>All values in its **right subtree** must be **greater than** the node's own value.
                </li>
                <li>Both its left and right subtrees must also be valid binary search trees.</li>
              </ul>
            </div>


            <h3 class="text-2xl font-bold mt-8 mb-4">The Power of the BST Property</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              This single rule allows us to discard half of the remaining data at every step of a search,
              similar to a binary search on a sorted array. This is why most core operations on a balanced
              BST are incredibly efficient, taking logarithmic time—<strong>$O(\log n)$</strong>.
            </p>
            <ul class="list-disc ml-5 space-y-3 mb-6">
              <li><strong>Search ($O(\log n)$):</strong> Start at the root. If the target value is less
                than the current node's value, go left. If it's greater, go right. Repeat until you find
                the value or hit a null pointer.</li>
              <li><strong>Insertion ($O(\log n)$):</strong> Follow the same path as a search. When you
                reach a null pointer, you've found the correct empty spot to insert the new node.</li>
              <li><strong>Deletion ($O(\log n)$):</strong> This is the most complex operation. It involves
                finding the node, and then handling three cases:
                <ol class="list-decimal ml-6 mt-2">
                  <li><strong>The node has no children:</strong> Simply remove it.</li>
                  <li><strong>The node has one child:</strong> Replace the node with its child.</li>
                  <li><strong>The node has two children:</strong> Find its "in-order successor" (the
                    smallest value in its right subtree), swap its value with the successor, and
                    then delete the successor.</li>
                </ol>
              </li>
            </ul>

            <h3 class="text-2xl font-bold mt-8 mb-4">Tree Traversal: How to Visit Every Node</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              There are two main approaches to visiting every node in a tree:
            </p>
            <div class="grid md:grid-cols-2 gap-8 mt-4">
              <div>
                <h4 class="font-bold text-lg mb-2">1. Depth-First Search (DFS)</h4>
                <p>Traverses as deep as possible down one path before backtracking. It's typically
                  implemented with recursion (using the call stack).</p>
                <ul class="list-disc ml-5 mt-2 space-y-2">
                  <li><strong>In-Order (Left, Root, Right):</strong> Visits the left subtree, then the
                    root, then the right subtree. <strong>For a BST, this prints the nodes in sorted
                      order!</strong></li>
                  <li><strong>Pre-Order (Root, Left, Right):</strong> Visits the root first. Useful
                    for creating a copy of a tree.</li>
                  <li><strong>Post-Order (Left, Right, Root):</strong> Visits the root last. Useful
                    for deleting a tree, as you delete children before their parent.</li>
                </ul>
              </div>
              <div>
                <h4 class="font-bold text-lg mb-2">2. Breadth-First Search (BFS)</h4>
                <p>Explores the tree level by level, from top to bottom. It's implemented with a
                  **Queue**.</p>
                <ul class="list-disc ml-5 mt-2 space-y-2">
                  <li><strong>Level-Order Traversal:</strong> Start by adding the root to a queue.
                    While the queue is not empty, dequeue a node, process it, and enqueue its
                    children.</li>
                </ul>
              </div>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-8 mb-4">BST Code Implementation</h3>
            <div class="code-tabs mb-2">
              <button class="tab-btn active" data-tab="bst-java">Java</button>
              <button class="tab-btn" data-tab="bst-cpp">C++</button>
              <button class="tab-btn" data-tab="bst-python">Python</button>
            </div>
            <!-- Java Code -->
            <div class="tab-content relative" id="bst-java">
              <pre><code class="language-java">// Binary Search Tree in Java
class TreeNode {
    int val;
    TreeNode left, right;
    public TreeNode(int val) { this.val = val; left = right = null; }
}

class BinarySearchTree {
    TreeNode root;

    public void insert(int val) { root = insertRec(root, val); }
    private TreeNode insertRec(TreeNode root, int val) {
        if (root == null) {
            root = new TreeNode(val);
            return root;
        }
        if (val < root.val) root.left = insertRec(root.left, val);
        else if (val > root.val) root.right = insertRec(root.right, val);
        return root;
    }

    public boolean search(int val) { return searchRec(root, val); }
    private boolean searchRec(TreeNode root, int val) {
        if (root == null) return false;
        if (root.val == val) return true;
        return val < root.val ? searchRec(root.left, val) : searchRec(root.right, val);
    }

    public void inOrder() { inOrderRec(root); }
    private void inOrderRec(TreeNode root) {
        if (root != null) {
            inOrderRec(root.left);
            System.out.print(root.val + " ");
            inOrderRec(root.right);
        }
    }
}</code></pre>
            </div>
            <!-- C++ Code -->
            <div class="tab-content relative hidden" id="bst-cpp">
              <pre><code class="language-cpp">// Binary Search Tree in C++
#include <iostream>

struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class BinarySearchTree {
public:
    TreeNode* root;
    BinarySearchTree() : root(nullptr) {}

    void insert(int val) { root = insertRec(root, val); }
    bool search(int val) { return searchRec(root, val); }
    void inOrder() { inOrderRec(root); }
private:
    TreeNode* insertRec(TreeNode* node, int val) {
        if (node == nullptr) return new TreeNode(val);
        if (val < node->val) node->left = insertRec(node->left, val);
        else if (val > node->val) node->right = insertRec(node->right, val);
        return node;
    }

    bool searchRec(TreeNode* node, int val) {
        if (node == nullptr) return false;
        if (node->val == val) return true;
        return val < node->val ? searchRec(node->left, val) : searchRec(node->right, val);
    }

    void inOrderRec(TreeNode* node) {
        if (node != nullptr) {
            inOrderRec(node->left);
            std::cout << node->val << " ";
            inOrderRec(node->right);
        }
    }
};</code></pre>
            </div>
            <!-- Python Code -->
            <div class="tab-content relative hidden" id="bst-python">
              <pre><code class="language-python"># Binary Search Tree in Python
class TreeNode:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, key):
        if self.root is None:
            self.root = TreeNode(key)
        else:
            self._insert_rec(self.root, key)

    def _insert_rec(self, node, key):
        if key < node.val:
            if node.left is None:
                node.left = TreeNode(key)
            else:
                self._insert_rec(node.left, key)
        else:
            if node.right is None:
                node.right = TreeNode(key)
            else:
                self._insert_rec(node.right, key)

    def search(self, key):
        return self._search_rec(self.root, key) is not None

    def _search_rec(self, node, key):
        if node is None or node.val == key:
            return node
        if key < node.val:
            return self._search_rec(node.left, key)
        return self._search_rec(node.right, key)

    def inorder(self):
        self._inorder_rec(self.root)

    def _inorder_rec(self, node):
        if node:
            self._inorder_rec(node.left)
            print(node.val, end=' ')
            self._inorder_rec(node.right)
</code></pre>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-12 mb-4">Top 5 Interview Questions</h3>
            <details class="mt-8 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <summary class="text-xl">View Essential Tree Interview Questions</summary>
              <ul class="list-decimal ml-5 space-y-4 mt-4">
                <li>
                  <a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Validate Binary
                    Search
                    Tree</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Determine if a given binary tree is a valid BST. <br><strong>Core Idea:</strong>
                    A simple check at each node is not enough. You must pass down `min` and `max`
                    constraints. For a node's left child, the new `max` constraint becomes the
                    node's value. For the right child, the new `min` constraint becomes the node's
                    value.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Maximum Depth of
                    Binary
                    Tree</a> - <span
                    class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Find the maximum depth (or height) of a binary tree. <br><strong>Core
                      Idea:</strong> A classic recursive solution. The depth of a tree is `1 +
                    max(depth of left subtree, depth of right subtree)`. The base case is a null
                    node, which has a depth of 0.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Binary Tree Level
                    Order
                    Traversal</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Traverse a tree level by level. <br><strong>Core Idea:</strong> The canonical
                    problem for Breadth-First Search (BFS). Use a queue. Add the root. Then, loop:
                    get the size of the queue for the current level, dequeue that many nodes, add
                    their values to a list for that level, and enqueue their children.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/"
                    target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Lowest Common Ancestor of
                    a BST</a> - <span
                    class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Find the lowest node that has two given nodes as descendants. <br><strong>Core
                      Idea:</strong> Take advantage of the BST property. Starting from the root,
                    if both target values are smaller, the LCA must be in the left subtree. If both
                    are larger, it's in the right. If the current node is between them (or is one of
                    them), you've found the LCA.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Invert Binary Tree</a> -
                  <span class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Mirror a binary tree. <br><strong>Core Idea:</strong> A simple recursive
                    solution. At each node, swap its left and right children. Then, recursively call
                    the function on the (new) left child and the (new) right child.</p>
                </li>
              </ul>
            </details>

            <div class="mt-12 flex justify-between">
              <a href="#queues" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm"><i
                  class="fas fa-arrow-left mr-2"></i> Prev: Queues</a>
              <a href="#graphs" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm">Next:
                Graphs <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
          </section>

          <section class="topic-section p-8 rounded-2xl" id="graphs" data-aos="fade-up"
            style="border-top-color: var(--color-graphs);">
            <h2 class="text-4xl font-bold flex items-center mb-4">
              <i class="fas fa-project-diagram mr-4" style="color: var(--color-graphs);"></i>Graphs: An
              In-Depth Guide to Networks
            </h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">
              If trees represent strict parent-child hierarchies, graphs represent the complex web of
              connections that define the real world. A social network, Google Maps, the World Wide Web
              itself—these are all graphs. A graph is a data structure that models relationships and
              networks, making it one of the most important and widely-applicable topics in computer
              science.
            </p>

            <h3 class="text-2xl font-bold mb-3">The Anatomy of a Graph</h3>
            <p class="mb-4">
              A graph is simply a collection of two things:
            </p>
            <ul class="list-disc ml-5 space-y-2 mb-6">
              <li><strong>Vertices (or Nodes):</strong> The fundamental entities or points in the graph.
                In a social network, a vertex is a person.</li>
              <li><strong>Edges (or Links):</strong> The connections between pairs of vertices. An edge
                represents a relationship, like a friendship between two people.</li>
            </ul>


            <h3 class="text-2xl font-bold mt-8 mb-4">Key Graph Terminology: The Flavors of Connection</h3>
            <div class="grid md:grid-cols-2 gap-8 mt-4">
              <div>
                <h4 class="font-bold text-lg mb-2">Directed vs. Undirected</h4>
                <p>An <strong>undirected</strong> graph has edges that are two-way streets (like a
                  Facebook friendship). A <strong>directed</strong> graph has edges that are one-way
                  streets, represented with arrows (like following someone on Twitter without them
                  following you back).</p>
              </div>
              <div>
                <h4 class="font-bold text-lg mb-2">Weighted vs. Unweighted</h4>
                <p>An <strong>unweighted</strong> graph's edges just signify a connection. A
                  <strong>weighted</strong> graph's edges have a "cost" or "weight" associated with
                  them. On a map, this weight could be the distance between two cities or the travel
                  time.
                </p>
              </div>
            </div>

            <h3 class="text-2xl font-bold mt-8 mb-4">Representing a Graph in Code: The Two Big Methods</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              How we store the vertices and edges in memory is a critical design decision.
            </p>
            <div class="grid md:grid-cols-2 gap-8 mt-4">
              <div>
                <h4 class="font-bold text-lg mb-2">1. Adjacency List</h4>
                <p>A collection (like a hash map or array) where each vertex stores a list of its
                  adjacent (neighboring) vertices. This is the most common representation for
                  real-world graphs, which are often "sparse" (not every node is connected to every
                  other node).</p>
              </div>
              <div>
                <h4 class="font-bold text-lg mb-2">2. Adjacency Matrix</h4>
                <p>A 2D array (a matrix) of size V x V, where V is the number of vertices. A value
                  `matrix[i][j] = 1` indicates an edge exists from vertex `i` to `j`. This is best for
                  "dense" graphs where connections are frequent.</p>
              </div>
            </div>

            <div class="overflow-x-auto bg-gray-50 dark:bg-gray-800 p-1 rounded-lg mt-8">
              <table class="w-full text-left">
                <thead class="bg-gray-100 dark:bg-gray-700">
                  <tr>
                    <th class="p-4 font-semibold">Comparison</th>
                    <th class="p-4 font-semibold">Adjacency List</th>
                    <th class="p-4 font-semibold">Adjacency Matrix</th>
                  </tr>
                </thead>
                <tbody>
                  <tr class="border-t border-gray-200 dark:border-gray-700">
                    <td class="p-4 font-medium">Space Complexity</td>
                    <td class="p-4 text-green-600 font-bold">$O(V+E)$</td>
                    <td class="p-4 text-red-600 font-bold">$O(V^2)$</td>
                  </tr>
                  <tr class="border-t border-gray-200 dark:border-gray-700">
                    <td class="p-4 font-medium">Check for Edge (u, v)</td>
                    <td class="p-4 text-red-600 font-bold">$O(k)$*</td>
                    <td class="p-4 text-green-600 font-bold">$O(1)$</td>
                  </tr>
                  <tr class="border-t border-gray-200 dark:border-gray-700">
                    <td class="p-4 font-medium">Iterate Neighbors of u</td>
                    <td class="p-4 text-green-600 font-bold">$O(k)$*</td>
                    <td class="p-4 text-red-600 font-bold">$O(V)$</td>
                  </tr>
                </tbody>
              </table>
              <p class="text-xs p-2 text-gray-500">*k = number of neighbors of vertex u (its degree)</p>
            </div>

            <h3 class="text-2xl font-bold mt-8 mb-4">Graph Traversal: How to Explore the Network</h3>
            <div class="grid md:grid-cols-2 gap-8 mt-4">
              <div>
                <h4 class="font-bold text-lg mb-2">Breadth-First Search (BFS)</h4>
                <p><strong>Analogy:</strong> A ripple effect in a pond. BFS explores the graph layer by
                  layer, visiting all of a node's direct neighbors before moving on to the next level.
                  <br><strong>Tool:</strong> A **Queue**.
                  <br><strong>Use Case:</strong> Finding the shortest path in an unweighted graph.
                </p>
              </div>
              <div>
                <h4 class="font-bold text-lg mb-2">Depth-First Search (DFS)</h4>
                <p><strong>Analogy:</strong> Exploring a maze. DFS goes as deep as possible down one
                  path before it's forced to backtrack and try another.
                  <br><strong>Tool:</strong> A **Stack** (usually the implicit call stack via
                  recursion).
                  <br><strong>Use Case:</strong> Detecting cycles, pathfinding, and topological
                  sorting.
                </p>
              </div>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-8 mb-4">Graph Code Implementation (Adjacency List)</h3>
            <div class="code-tabs mb-2">
              <button class="tab-btn active" data-tab="graph-java">Java</button>
              <button class="tab-btn" data-tab="graph-cpp">C++</button>
              <button class="tab-btn" data-tab="graph-python">Python</button>
            </div>
            <!-- Java Code -->
            <div class="tab-content relative" id="graph-java">
              <pre><code class="language-java">// Graph in Java (Adjacency List)
import java.util.*;

class Graph<T> {
    private Map<T, List<T>> adj = new HashMap<>();

    public void addVertex(T vertex) {
        adj.putIfAbsent(vertex, new ArrayList<>());
    }

    public void addEdge(T v1, T v2) { // For Undirected Graph
        adj.get(v1).add(v2);
        adj.get(v2).add(v1);
    }

    public void dfs(T start) {
        Set<T> visited = new HashSet<>();
        dfsRecursive(start, visited);
    }
    private void dfsRecursive(T vertex, Set<T> visited) {
        visited.add(vertex);
        System.out.print(vertex + " ");
        for (T neighbor : adj.get(vertex)) {
            if (!visited.contains(neighbor)) {
                dfsRecursive(neighbor, visited);
            }
        }
    }

    public void bfs(T start) {
        Set<T> visited = new HashSet<>();
        Queue<T> queue = new LinkedList<>();
        visited.add(start);
        queue.add(start);
        while (!queue.isEmpty()) {
            T vertex = queue.poll();
            System.out.print(vertex + " ");
            for (T neighbor : adj.get(vertex)) {
                if (!visited.contains(neighbor)) {
                    visited.add(neighbor);
                    queue.add(neighbor);
                }
            }
        }
    }
}</code></pre>
            </div>
            <!-- C++ Code -->
            <div class="tab-content relative hidden" id="graph-cpp">
              <pre><code class="language-cpp">// Graph in C++ (Adjacency List)
#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <queue>

template<typename T>
class Graph {
private:
    std::unordered_map<T, std::vector<T>> adj;

public:
    void addVertex(T vertex) {
        // Automatically handled by map
    }

    void addEdge(T v1, T v2) {
        adj[v1].push_back(v2);
        adj[v2].push_back(v1);
    }

    void dfs(T start) {
        std::unordered_set<T> visited;
        dfsRecursive(start, visited);
    }

    void bfs(T start) {
        std::unordered_set<T> visited;
        std::queue<T> q;
        visited.insert(start);
        q.push(start);
        while (!q.empty()) {
            T vertex = q.front();
            q.pop();
            std::cout << vertex << " ";
            for (T neighbor : adj[vertex]) {
                if (visited.find(neighbor) == visited.end()) {
                    visited.insert(neighbor);
                    q.push(neighbor);
                }
            }
        }
    }
private:
    void dfsRecursive(T vertex, std::unordered_set<T>& visited) {
        visited.insert(vertex);
        std::cout << vertex << " ";
        for (T neighbor : adj[vertex]) {
            if (visited.find(neighbor) == visited.end()) {
                dfsRecursive(neighbor, visited);
            }
        }
    }
};</code></pre>
            </div>
            <!-- Python Code -->
            <div class="tab-content relative hidden" id="graph-python">
              <pre><code class="language-python"># Graph in Python (Adjacency List)
from collections import defaultdict

class Graph:
    def __init__(self):
        # Using defaultdict simplifies adding vertices
        self.adj = defaultdict(list)

    def add_edge(self, u, v):
        self.adj[u].append(v)
        self.adj[v].append(u)

    def dfs(self, start):
        visited = set()
        self._dfs_recursive(start, visited)

    def _dfs_recursive(self, vertex, visited):
        visited.add(vertex)
        print(vertex, end=' ')
        for neighbor in self.adj[vertex]:
            if neighbor not in visited:
                self._dfs_recursive(neighbor, visited)

    def bfs(self, start):
        visited = {start}
        queue = [start]
        while queue:
            vertex = queue.pop(0)
            print(vertex, end=' ')
            for neighbor in self.adj[vertex]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
</code></pre>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-12 mb-4">Top 5 Interview Questions</h3>
            <details class="mt-8 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <summary class="text-xl">View Essential Graph Interview Questions</summary>
              <ul class="list-decimal ml-5 space-y-4 mt-4">
                <li>
                  <a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Number of Islands</a> -
                  <span class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Count the number of islands in a 2D grid of land ('1') and water ('0').
                    <br><strong>Core Idea:</strong> The canonical grid traversal problem. Iterate
                    through every cell. If you find a '1', increment your island count and start a
                    traversal (either BFS or DFS) from that cell to find and mark all connected land
                    parts as visited.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Clone Graph</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Create a deep copy of a graph. <br><strong>Core Idea:</strong> This tests
                    traversal and keeping track of created nodes. Use a hash map to store a mapping
                    from an original node to its clone. Traverse the original graph (with BFS or
                    DFS), and for each node, if its clone isn't in the map, create it. Then, connect
                    the clones based on the original's connections.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Course Schedule</a> -
                  <span class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given course prerequisites, determine if it's possible to finish all courses.
                    <br><strong>Core Idea:</strong> This is a cycle detection problem in a directed
                    graph. A cycle means an impossible prerequisite loop (e.g., A needs B, and B
                    needs A). Use DFS with a `visiting` set to detect back edges, which indicate a
                    cycle.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Word Ladder</a> - <span
                    class="text-sm font-semibold bg-red-500 text-red-100 px-2 py-1 rounded">Hard</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Find the length of the shortest transformation sequence from a `beginWord` to an
                    `endWord`, changing one letter at a time, using a given word list.
                    <br><strong>Core Idea:</strong> This is a classic "shortest path in an
                    unweighted graph" problem. The words are the vertices, and an edge exists
                    between two words if they differ by one letter. Use BFS to find the shortest
                    path from the start to the end.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/rotting-oranges/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Rotting Oranges</a> -
                  <span class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    In a grid of oranges, find the minimum time until no fresh oranges are left.
                    Rotting propagates to adjacent fresh oranges each minute. <br><strong>Core
                      Idea:</strong> This is a multi-source BFS problem. Initialize the queue with
                    the coordinates of all initially rotten oranges. The level of the BFS
                    corresponds to the number of minutes passed.</p>
                </li>
              </ul>
            </details>

            <div class="mt-12 flex justify-between">
              <a href="#trees" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm"><i
                  class="fas fa-arrow-left mr-2"></i> Prev: Trees</a>
              <a href="#searching" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm">Next:
                Searching <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
          </section>

          <section class="topic-section p-8 rounded-2xl" id="searching" data-aos="fade-up"
            style="border-top-color: var(--color-searching);">
            <h2 class="text-4xl font-bold flex items-center mb-4">
              <i class="fas fa-search mr-4" style="color: var(--color-searching);"></i>Searching
              Algorithms: An In-Depth Guide
            </h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">
              Searching is the process of finding the location of a specific element within a collection
              of data. It's an operation we perform countless times a day, from finding a contact on our
              phone to searching for a file on a computer. The efficiency of your search algorithm can be
              the difference between a lightning-fast application and one that feels unusably slow.
            </p>

            <h3 class="text-2xl font-bold mb-3">The Two Pillars of Searching in Linear Data</h3>
            <p class="mb-4">
              When data is stored in a list or array, there are two primary strategies for finding what
              you're looking for. The choice between them depends entirely on one question: **Is the data
              sorted?**
            </p>

            <!-- ======================================================================= -->
            <!-- ======================= LINEAR SEARCH ================================= -->
            <!-- ======================================================================= -->
            <div class="topic-section p-6 rounded-xl border-t-4 mt-8" style="border-top-color: var(--color-searching)">
              <h4 class="text-2xl font-bold mb-3">1. Linear Search: The Brute-Force Method</h4>
              <p class="mb-4">
                <strong>Analogy:</strong> Searching for a specific playing card in a shuffled deck. You
                have no strategy; you simply turn over each card, one by one, from the beginning until
                you find the one you're looking for.
              </p>
              <p class="mb-4">
                This is the most basic search algorithm. It sequentially checks each element of the list
                until a match is found or the whole list has been searched.
              </p>
              <ul class="list-disc ml-5 space-y-2 mb-6">
                <li><strong>Time Complexity: $O(n)$</strong> — In the worst case, you have to look at
                  every single one of the `n` elements.</li>
                <li><strong>Space Complexity: $O(1)$</strong> — It requires no extra memory.</li>
                <li><strong>Requirement:</strong> None. It works on any list, sorted or unsorted.</li>
              </ul>

              <div class="code-tabs mb-2">
                <button class="tab-btn active" data-tab="linear-java">Java</button>
                <button class="tab-btn" data-tab="linear-cpp">C++</button>
                <button class="tab-btn" data-tab="linear-python">Python</button>
              </div>
              <div class="tab-content relative" id="linear-java">
                <pre><code class="language-java">// Linear Search in Java
class LinearSearch {
    public static int search(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Return index if found
            }
        }
        return -1; // Return -1 if not found
    }
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="linear-cpp">
                <pre><code class="language-cpp">// Linear Search in C++
#include <vector>

int linear_search(const std::vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == target) {
            return i; // Return index if found
        }
    }
    return -1; // Return -1 if not found
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="linear-python">
                <pre><code class="language-python"># Linear Search in Python
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Return index if found
    return -1  # Return -1 if not found
</code></pre>
              </div>
            </div>

            <!-- ======================================================================= -->
            <!-- ======================= BINARY SEARCH ================================= -->
            <!-- ======================================================================= -->
            <div class="topic-section p-6 rounded-xl border-t-4 mt-8" style="border-top-color: var(--color-searching)">
              <h4 class="text-2xl font-bold mb-3">2. Binary Search: The Divide and Conquer Masterpiece
              </h4>
              <p class="mb-4">
                <strong>Analogy:</strong> Looking up a word in a dictionary. You don't start at
                "Aardvark." You open to the middle, see if your word comes before or after, and
                instantly discard half the book. You repeat this process, halving the search space with
                every step.
              </p>
              <div
                class="bg-red-100 dark:bg-red-900 border-l-4 border-red-500 text-red-700 dark:text-red-200 p-4 rounded mb-4">
                <p class="font-bold">CRITICAL PREREQUISITE: The data must be sorted!</p>
              </div>
              <p class="mb-4">
                Binary search works by repeatedly dividing the search interval in half. If the value of
                the search key is less than the item in the middle of the interval, narrow the interval
                to the lower half. Otherwise, narrow it to the upper half.
              </p>
              <ul class="list-disc ml-5 space-y-2 mb-6">
                <li><strong>Time Complexity: $O(\log n)$</strong> — With each step, you eliminate half
                  of the remaining elements. This is astronomically faster than $O(n)$ for large
                  datasets.</li>
                <li><strong>Space Complexity: $O(1)$</strong> — The iterative version uses no extra
                  space.</li>
                <li><strong>Requirement:</strong> The data must be sorted.</li>
              </ul>

              <div class="code-tabs mb-2">
                <button class="tab-btn active" data-tab="binary-java">Java</button>
                <button class="tab-btn" data-tab="binary-cpp">C++</button>
                <button class="tab-btn" data-tab="binary-python">Python</button>
              </div>
              <div class="tab-content relative" id="binary-java">
                <pre><code class="language-java">// Iterative Binary Search in Java
class BinarySearch {
    public static int search(int[] arr, int target) {
        int low = 0;
        int high = arr.length - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2; // Avoids overflow
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return -1; // Not found
    }
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="binary-cpp">
                <pre><code class="language-cpp">// Iterative Binary Search in C++
#include <vector>

int binary_search(const std::vector<int>& arr, int target) {
    int low = 0;
    int high = arr.size() - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2; // Avoids overflow
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1; // Not found
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="binary-python">
                <pre><code class="language-python"># Iterative Binary Search in Python
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1  # Not found
</code></pre>
              </div>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-12 mb-4">Top 5 Interview Questions</h3>
            <details class="mt-8 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <summary class="text-xl">View Essential Searching Interview Questions</summary>
              <ul class="list-decimal ml-5 space-y-4 mt-4">
                <li>
                  <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Search in Rotated
                    Sorted
                    Array</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong> A
                    sorted array is "rotated" at some pivot (e.g., `[4,5,6,7,0,1,2]`). Find a target
                    value in it. <br><strong>Core Idea:</strong> This is a modified binary search.
                    At each step, after finding the middle, you must first determine which half of
                    the array is sorted. Then, you can decide whether your target lies in the sorted
                    half or the unsorted half and adjust your `low` and `high` pointers accordingly.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/"
                    target="_blank" rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Find
                    First and Last
                    Position of Element</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    In a sorted array with duplicates, find the starting and ending index of a given
                    target. <br><strong>Core Idea:</strong> Run binary search twice. The first
                    search finds the target, but then continues searching in the left half to find
                    the "first" occurrence. The second search finds the target and continues
                    searching in the right half to find the "last" occurrence.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Find Minimum in
                    Rotated
                    Sorted Array</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Find the minimum element in a rotated sorted array. <br><strong>Core
                      Idea:</strong> Another modified binary search. The minimum element is the
                    "pivot." By comparing the middle element with the rightmost element, you can
                    determine if the pivot (the minimum) is in the left or right half and discard
                    the other half.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/find-peak-element/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Find a Peak Element</a> -
                  <span class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Find any element in an array that is greater than its neighbors.
                    <br><strong>Core Idea:</strong> Binary search can be applied here. If the middle
                    element is smaller than its right neighbor, a peak must exist in the right half.
                    If it's smaller than its left neighbor, a peak must exist in the left half. This
                    allows you to discard half the array at each step.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/koko-eating-bananas/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Koko Eating Bananas</a> -
                  <span class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Find the minimum eating speed `k` such that Koko can eat all bananas within `h`
                    hours. <br><strong>Core Idea:</strong> This is "Binary Search on the Answer."
                    Instead of searching for an index, you search for a *value* (the speed `k`). The
                    search space is from `1` to `max(piles)`. For a given speed `mid`, you can check
                    if it's possible to finish in time. If yes, try a smaller speed; if no, you must
                    try a larger speed.</p>
                </li>
              </ul>
            </details>

            <div class="mt-12 flex justify-between">
              <a href="#graphs" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm"><i
                  class="fas fa-arrow-left mr-2"></i> Prev: Graphs</a>
              <a href="#sorting" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm">Next:
                Sorting <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
          </section>

          <section class="topic-section p-8 rounded-2xl" id="sorting" data-aos="fade-up"
            style="border-top-color: var(--color-sorting);">
            <h2 class="text-4xl font-bold flex items-center mb-4">
              <i class="fas fa-sort-amount-up-alt mr-4" style="color: var(--color-sorting);"></i>Sorting
              Algorithms: An In-Depth Guide
            </h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">
              Sorting is the process of arranging a collection of items into a specific order (most
              commonly, numerical or alphabetical). While it seems simple, the efficiency of a sorting
              algorithm can have a massive impact on an application's performance. Mastering sorting is a
              rite of passage for every developer, as it teaches fundamental concepts like complexity,
              trade-offs, and algorithmic strategy.
            </p>

            <h3 class="text-2xl font-bold mt-8 mb-4">Categories of Sorting Algorithms</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              We'll explore two main categories: the simple, intuitive algorithms ($O(n^2)$), and the
              efficient, advanced algorithms ($O(n \log n)$).
            </p>

            <!-- ======================================================================= -->
            <!-- ======================= BUBBLE SORT =================================== -->
            <!-- ======================================================================= -->
            <div class="topic-section p-6 rounded-xl border-t-4 mt-8" style="border-top-color: var(--color-sorting)">
              <h4 class="text-2xl font-bold mb-3">1. Bubble Sort: The Sinking Stone</h4>
              <p class="mb-2"><strong>Analogy:</strong> Imagine a line of people of different heights. You
                compare the first two people and swap them if the taller person is on the left. You
                repeat this for every adjacent pair. The tallest person will "bubble up" to the end of
                the line. Repeat this process, and the line will eventually be sorted.</p>
              <p class="mb-4"><strong>Strategy:</strong> Repeatedly step through the list, compare
                adjacent elements, and swap them if they are in the wrong order. After each pass, the
                next largest element is in its correct final position.</p>
              <div class="mb-4">
                <p class="font-semibold">Visual Explanation (Sorting [5, 1, 4, 2]):</p>
                <pre class="bg-gray-100 dark:bg-gray-800 p-4 mt-2 rounded-lg font-mono text-sm">
Pass 1:
[<span class="text-red-500">5, 1</span>, 4, 2] -> [<span class="text-green-500">1, 5</span>, 4, 2]
[1, <span class="text-red-500">5, 4</span>, 2] -> [1, <span class="text-green-500">4, 5</span>, 2]
[1, 4, <span class="text-red-500">5, 2</span>] -> [1, 4, <span class="text-green-500">2, 5</span>] -> (Largest element 5 is now at the end)

Pass 2:
[<span class="text-red-500">1, 4</span>, 2, 5] -> [1, 4, 2, 5] (no swap)
[1, <span class="text-red-500">4, 2</span>, 5] -> [1, <span class="text-green-500">2, 4</span>, 5] -> (Next largest 4 is in place)

Pass 3:
[<span class="text-red-500">1, 2</span>, 4, 5] -> [1, 2, 4, 5] (no swap) -> Sorted!
            </pre>
              </div>
              <p><strong>Performance:</strong> Time: $O(n^2)$, Space: $O(1)$. It's simple but highly
                inefficient for large datasets.</p>

              <div class="code-tabs mb-2 mt-4">
                <button class="tab-btn active" data-tab="bubble-java">Java</button>
                <button class="tab-btn" data-tab="bubble-cpp">C++</button>
                <button class="tab-btn" data-tab="bubble-python">Python</button>
              </div>
              <div class="tab-content relative" id="bubble-java">
                <pre><code class="language-java">void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="bubble-cpp">
                <pre><code class="language-cpp">#include <vector>
#include <utility> // For std::swap
void bubbleSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                std::swap(arr[j], arr[j + 1]);
            }
        }
    }
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="bubble-python">
                <pre><code class="language-python">def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
</code></pre>
              </div>
            </div>

            <!-- ======================================================================= -->
            <!-- ======================= SELECTION SORT ================================ -->
            <!-- ======================================================================= -->
            <div class="topic-section p-6 rounded-xl border-t-4 mt-8" style="border-top-color: var(--color-sorting)">
              <h4 class="text-2xl font-bold mb-3">2. Selection Sort: The Methodical Organizer</h4>
              <p class="mb-2"><strong>Analogy:</strong> Arranging a hand of playing cards. You look
                through all your unsorted cards to find the lowest one and place it at the very
                beginning. Then, you look through the remaining unsorted cards for the next-lowest and
                place it in the second position. You repeat until all cards are sorted.</p>
              <p class="mb-4"><strong>Strategy:</strong> The list is divided into two parts: a sorted
                sublist at the beginning and an unsorted sublist at the end. In each iteration, find the
                minimum element from the unsorted sublist and swap it with the first element of the
                unsorted part.</p>
              <div class="mb-4">
                <p class="font-semibold">Visual Explanation (Sorting [5, 1, 4, 2]):</p>
                <pre class="bg-gray-100 dark:bg-gray-800 p-4 mt-2 rounded-lg font-mono text-sm">
Sorted | Unsorted
-------------------
[]     | [5, 1, 4, 2] -> Find min (1). Swap with first (5).
[1]    | [<span class="text-green-500">5</span>, 4, 2] -> Find min (2). Swap with first (5).
[1, 2] | [4, <span class="text-green-500">5</span>] -> Find min (4). Swap with first (4).
[1, 2, 4] | [5]      -> Find min (5). Swap with first (5).
[1, 2, 4, 5] | []     -> Sorted!
            </pre>
              </div>
              <p><strong>Performance:</strong> Time: $O(n^2)$ (always), Space: $O(1)$. It performs the
                minimum possible number of swaps, but the number of comparisons is always high.</p>

              <div class="code-tabs mb-2 mt-4">
                <button class="tab-btn active" data-tab="selection-java">Java</button>
                <button class="tab-btn" data-tab="selection-cpp">C++</button>
                <button class="tab-btn" data-tab="selection-python">Python</button>
              </div>
              <div class="tab-content relative" id="selection-java">
                <pre><code class="language-java">void selectionSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        int temp = arr[minIdx];
        arr[minIdx] = arr[i];
        arr[i] = temp;
    }
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="selection-cpp">
                <pre><code class="language-cpp">#include <vector>
#include <utility> // For std::swap
void selectionSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        std::swap(arr[minIdx], arr[i]);
    }
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="selection-python">
                <pre><code class="language-python">def selection_sort(arr):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
</code></pre>
              </div>
            </div>

            <!-- ======================================================================= -->
            <!-- ======================= MERGE SORT ==================================== -->
            <!-- ======================================================================= -->
            <div class="topic-section p-6 rounded-xl border-t-4 mt-8" style="border-top-color: var(--color-sorting)">
              <h4 class="text-2xl font-bold mb-3">3. Merge Sort: The Ultimate Organizer</h4>
              <p class="mb-2"><strong>Analogy:</strong> A librarian is given a massive, unsorted pile of
                books. She splits the pile in half, gives each half to an assistant, and asks them to
                sort their smaller piles. They do the same, splitting their piles until each assistant
                has only one book (which is, by definition, sorted). Then, the assistants start merging
                their single books back into sorted piles of two, then four, and so on, until the
                librarian gets back two large, sorted piles, which she merges one final time.</p>
              <p class="mb-4"><strong>Strategy:</strong> A "Divide and Conquer" algorithm. It recursively
                divides the list into halves until it has `n` sublists of size 1. Then, it repeatedly
                merges these sorted sublists to produce new, larger sorted sublists until only one
                sorted list remains.</p>
              <div class="mb-4">
                <p class="font-semibold">Visual Explanation (Sorting [5, 1, 4, 2]):</p>
                <pre class="bg-gray-100 dark:bg-gray-800 p-4 mt-2 rounded-lg font-mono text-sm">
1. Split:
      [5, 1, 4, 2]
     /            \
   [5, 1]        [4, 2]
  /      \      /      \
[5]      [1]    [4]      [2]

2. Merge:
  \      /      \      /
   [<span class="text-green-500">1, 5</span>]        [<span class="text-green-500">2, 4</span>]
     \            /
      [<span class="text-green-500">1, 2, 4, 5</span>]  -> Sorted!
            </pre>
              </div>
              <p><strong>Performance:</strong> Time: $O(n \log n)$ (always), Space: $O(n)$. It's
                incredibly consistent and stable, but requires extra memory for the merging process.</p>

              <div class="code-tabs mb-2 mt-4">
                <button class="tab-btn active" data-tab="merge-java">Java</button>
                <button class="tab-btn" data-tab="merge-cpp">C++</button>
                <button class="tab-btn" data-tab="merge-python">Python</button>
              </div>
              <div class="tab-content relative" id="merge-java">
                <pre><code class="language-java">class MergeSort {
    void merge(int arr[], int l, int m, int r) {
        // ... Merge helper function implementation ...
    }
    void sort(int arr[], int l, int r) {
        if (l < r) {
            int m = l + (r - l) / 2;
            sort(arr, l, m);
            sort(arr, m + 1, r);
            merge(arr, l, m, r);
        }
    }
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="merge-cpp">
                <pre><code class="language-cpp">#include <vector>
void merge(std::vector<int>& arr, int l, int m, int r) {
    // ... Merge helper function implementation ...
}
void mergeSort(std::vector<int>& arr, int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="merge-python">
                <pre><code class="language-python">def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        L = arr[:mid]
        R = arr[mid:]
        merge_sort(L)
        merge_sort(R)
        # ... Merging logic ...
        i = j = k = 0
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
        # ... Copy remaining elements ...
</code></pre>
              </div>
            </div>

            <!-- ======================================================================= -->
            <!-- ======================= QUICK SORT ==================================== -->
            <!-- ======================================================================= -->
            <div class="topic-section p-6 rounded-xl border-t-4 mt-8" style="border-top-color: var(--color-sorting)">
              <h4 class="text-2xl font-bold mb-3">4. Quick Sort: The Fast Partitioner</h4>
              <p class="mb-2"><strong>Analogy:</strong> A drill sergeant wants to line up soldiers by
                height. He picks one soldier as a "pivot" and yells, "Everyone shorter than the pivot,
                get to his left! Everyone taller, get to his right!" Now the pivot soldier is in his
                correct final position. The sergeant then gives the same command to the sergeants in
                charge of the two unsorted groups, and this process repeats until everyone is sorted.
              </p>
              <p class="mb-4"><strong>Strategy:</strong> Another "Divide and Conquer" algorithm. It picks
                an element as a pivot and partitions the array around the pivot, placing smaller
                elements to its left and larger elements to its right. The pivot is now sorted. The
                process is then repeated recursively for the two sub-arrays.</p>
              <div class="mb-4">
                <p class="font-semibold">Visual Explanation (Sorting [5, 1, 4, 2, 8], Pivot=5):</p>
                <pre class="bg-gray-100 dark:bg-gray-800 p-4 mt-2 rounded-lg font-mono text-sm">
Initial: [5, 1, 4, 2, 8] -> Pivot is 5

Partition:
Rearrange to put elements < 5 on left, > 5 on right.
Result:  [<span class="text-red-500">1, 4, 2</span>, <span class="text-green-500">5</span>, <span class="text-blue-500">8</span>] -> 5 is now in its final sorted position.

Recursive Sort:
Sort left part [1, 4, 2] and right part [8] separately.
            </pre>
              </div>
              <p><strong>Performance:</strong> Time: $O(n \log n)$ (Average/Best), $O(n^2)$ (Worst),
                Space: $O(\log n)$ (for recursion stack). It is often faster in practice than Merge Sort
                but has a worst-case scenario if the pivots are poorly chosen.</p>

              <div class="code-tabs mb-2 mt-4">
                <button class="tab-btn active" data-tab="quick-java">Java</button>
                <button class="tab-btn" data-tab="quick-cpp">C++</button>
                <button class="tab-btn" data-tab="quick-python">Python</button>
              </div>
              <div class="tab-content relative" id="quick-java">
                <pre><code class="language-java">class QuickSort {
    int partition(int[] arr, int low, int high) {
        // ... Partition helper logic ...
    }
    void sort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            sort(arr, low, pi - 1);
            sort(arr, pi + 1, high);
        }
    }
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="quick-cpp">
                <pre><code class="language-cpp">#include <vector>
#include <utility>
int partition(std::vector<int>& arr, int low, int high) {
    // ... Partition helper logic ...
}
void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="quick-python">
                <pre><code class="language-python">def partition(arr, low, high):
    # ... Partition helper logic ...
    pass

def quick_sort(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)
        quick_sort(arr, low, pi - 1)
        quick_sort(arr, pi + 1, high)
</code></pre>
              </div>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-12 mb-4">Top 5 Interview Questions</h3>
            <details class="mt-8 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <summary class="text-xl">View Essential Sorting Interview Questions</summary>
              <ul class="list-decimal ml-5 space-y-4 mt-4">
                <li>
                  <a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Merge Sorted Array</a> -
                  <span class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    You are given two sorted arrays and need to merge the second one into the first
                    one in-place. <br><strong>Core Idea:</strong> This tests your understanding of
                    the "merge" step in Merge Sort. The key is to start filling the first array from
                    the end, comparing the largest elements of both arrays to avoid overwriting
                    values.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Sort Colors</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Sort an array of 0s, 1s, and 2s in-place. <br><strong>Core Idea:</strong> This
                    is a variation of the partitioning step in Quick Sort, known as the Dutch
                    National Flag problem. Use three pointers (`low`, `mid`, `high`) to place all 0s
                    before `low`, all 2s after `high`, and all 1s in between.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Kth Largest Element
                    in an
                    Array</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Find the kth largest element in an unsorted array. <br><strong>Core
                      Idea:</strong> A naive solution is to sort the array ($O(n \log n)$) and
                    pick the element. The optimal solution uses the partitioning logic from Quick
                    Sort (often called Quickselect). After partitioning, you know the pivot's rank.
                    You can then recursively search in only the left or right part, leading to an
                    average time complexity of $O(n)$.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Merge Intervals</a> -
                  <span class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given a collection of intervals, merge all overlapping intervals.
                    <br><strong>Core Idea:</strong> The crucial first step is to sort the intervals
                    based on their start times. Once sorted, you can iterate through them and easily
                    merge any interval that overlaps with the previous one.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/car-fleet/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Car Fleet</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Calculate the number of car fleets that will arrive at a destination.
                    <br><strong>Core Idea:</strong> This problem becomes much simpler after sorting.
                    Sort the cars by their starting position. Then, iterate from the car closest to
                    the target backwards. A new fleet is formed only when a car takes longer to
                    reach the target than the fleet ahead of it.
                  </p>
                </li>
              </ul>
            </details>

            <div class="mt-12 flex justify-between">
              <a href="#searching" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm"><i
                  class="fas fa-arrow-left mr-2"></i> Prev: Searching</a>
              <a href="#recursion" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm">Next:
                Recursion <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
          </section>

          <section class="topic-section p-8 rounded-2xl" id="recursion" data-aos="fade-up"
            style="border-top-color: var(--color-recursion);">
            <h2 class="text-4xl font-bold flex items-center mb-4">
              <i class="fas fa-undo-alt mr-4" style="color: var(--color-recursion);"></i>Recursion: An
              In-Depth Guide to Self-Reference
            </h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">
              Recursion is one of the most elegant and powerful concepts in computer science. At its core,
              it's a problem-solving technique where a function calls itself to solve smaller, identical
              versions of the same problem. Instead of thinking in loops, you think about breaking a big
              problem down into the simplest possible case and a rule for how to get there.
            </p>

            <h3 class="text-2xl font-bold mb-3">The Core Idea: A Set of Russian Dolls</h3>
            <p class="mb-4">
              Imagine you have a set of Russian nesting dolls. Your task is to find the smallest doll.
              <br><strong>The recursive strategy is:</strong> "If this doll isn't the smallest, I will
              solve the problem of finding the smallest doll within the *next smaller doll inside this
              one*."
              You keep applying this same logic until you open a doll that is solid—that's your answer.
              Recursion is this exact process of breaking a problem down into a smaller version of itself.

            </p>

            <h3 class="text-2xl font-bold mt-8 mb-4">The Two Golden Rules of Recursion</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              Every correct recursive function, without exception, must have two parts. Missing either one
              will lead to infinite loops and a "stack overflow" error.
            </p>
            <div class="grid md:grid-cols-2 gap-8 mt-4">
              <div>
                <h4 class="font-bold text-lg mb-2">1. The Base Case (The Stopping Condition)</h4>
                <p>This is the simplest possible version of the problem, one that can be answered
                  directly without making another recursive call. It's the solid, smallest Russian
                  doll that cannot be opened further. It's the anchor that stops the chain reaction.
                </p>
              </div>
              <div>
                <h4 class="font-bold text-lg mb-2">2. The Recursive Step (The Work)</h4>
                <p>This is the logic where the function calls itself, but with an input that is somehow
                  closer to the base case. It's the act of opening the current doll to find the next
                  smaller one inside. The key is that the problem must get simpler with each call.</p>
              </div>
            </div>

            <h3 class="text-2xl font-bold mt-8 mb-4">How It Works: The "Call Stack"</h3>
            <p class="mb-4">
              How does the computer keep track of all these nested calls? It uses a data structure we've
              already seen: a **Stack**. The "Call Stack" is a stack of "to-do" notes that the computer
              maintains.
            </p>
            <ul class="list-disc ml-5 space-y-2 mb-6">
              <li>When a function is called, the computer pushes its details (local variables, what to do
                next) onto the top of the call stack.</li>
              <li>If that function calls another function (or itself), the new function's details are
                pushed on top of it.</li>
              <li>When a function finishes (hits a `return`), its details are popped off the stack, and
                control returns to the function below it.</li>
            </ul>

            <div class="mb-4">
              <p class="font-semibold">Visualizing `factorial(3)` on the Call Stack:</p>
              <pre class="bg-gray-100 dark:bg-gray-800 p-4 mt-2 rounded-lg font-mono text-sm">
1. call factorial(3) -> PUSH factorial(3) to stack
   Stack: [factorial(3)]
2. factorial(3) calls factorial(2) -> PUSH factorial(2)
   Stack: [factorial(3), factorial(2)]
3. factorial(2) calls factorial(1) -> PUSH factorial(1)
   Stack: [factorial(3), factorial(2), factorial(1)]

4. factorial(1) is the base case. It returns 1. POP factorial(1).
   Stack: [factorial(3), factorial(2)]
5. factorial(2) gets 1, returns 2 * 1 = 2. POP factorial(2).
   Stack: [factorial(3)]
6. factorial(3) gets 2, returns 3 * 2 = 6. POP factorial(3).
   Stack: [] -> Final answer is 6.
        </pre>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-8 mb-4">Classic Recursive Algorithms</h3>

            <!-- Factorial -->
            <div class="topic-section p-6 rounded-xl border-t-4 mt-8" style="border-top-color: var(--color-recursion)">
              <h4 class="text-2xl font-bold mb-3">1. Factorial</h4>
              <p class="mb-4">Calculates n! (n * (n-1) * ... * 1).</p>
              <ul class="list-disc ml-5 space-y-1 mb-4">
                <li><strong>Base Case:</strong> `factorial(1)` is `1`.</li>
                <li><strong>Recursive Step:</strong> `factorial(n)` is `n * factorial(n - 1)`.</li>
              </ul>
              <div class="code-tabs mb-2">
                <button class="tab-btn active" data-tab="fact-java">Java</button>
                <button class="tab-btn" data-tab="fact-cpp">C++</button>
                <button class="tab-btn" data-tab="fact-python">Python</button>
              </div>
              <div class="tab-content relative" id="fact-java">
                <pre><code class="language-java">long factorial(int n) {
    // Base Case
    if (n <= 1) {
        return 1;
    }
    // Recursive Step
    return n * factorial(n - 1);
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="fact-cpp">
                <pre><code class="language-cpp">long long factorial(int n) {
    // Base Case
    if (n <= 1) {
        return 1;
    }
    // Recursive Step
    return n * factorial(n - 1);
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="fact-python">
                <pre><code class="language-python">def factorial(n):
    # Base Case
    if n <= 1:
        return 1
    # Recursive Step
    return n * factorial(n - 1)
</code></pre>
              </div>
            </div>

            <!-- Fibonacci -->
            <div class="topic-section p-6 rounded-xl border-t-4 mt-8" style="border-top-color: var(--color-recursion)">
              <h4 class="text-2xl font-bold mb-3">2. Fibonacci Sequence</h4>
              <p class="mb-4">Finds the nth number in the sequence (0, 1, 1, 2, 3, 5, 8...).</p>
              <ul class="list-disc ml-5 space-y-1 mb-4">
                <li><strong>Base Cases:</strong> `fib(0)` is `0`, `fib(1)` is `1`.</li>
                <li><strong>Recursive Step:</strong> `fib(n)` is `fib(n - 1) + fib(n - 2)`.</li>
              </ul>
              <div class="code-tabs mb-2">
                <button class="tab-btn active" data-tab="fib-java">Java</button>
                <button class="tab-btn" data-tab="fib-cpp">C++</button>
                <button class="tab-btn" data-tab="fib-python">Python</button>
              </div>
              <div class="tab-content relative" id="fib-java">
                <pre><code class="language-java">int fibonacci(int n) {
    // Base Cases
    if (n <= 1) {
        return n;
    }
    // Recursive Step
    return fibonacci(n - 1) + fibonacci(n - 2);
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="fib-cpp">
                <pre><code class="language-cpp">int fibonacci(int n) {
    // Base Cases
    if (n <= 1) {
        return n;
    }
    // Recursive Step
    return fibonacci(n - 1) + fibonacci(n - 2);
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="fib-python">
                <pre><code class="language-python">def fibonacci(n):
    # Base Cases
    if n <= 1:
        return n
    # Recursive Step
    return fibonacci(n - 1) + fibonacci(n - 2)
</code></pre>
              </div>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-12 mb-4">Top 5 Interview Questions</h3>
            <details class="mt-8 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <summary class="text-xl">View Essential Recursion Interview Questions</summary>
              <ul class="list-decimal ml-5 space-y-4 mt-4">
                <li>
                  <a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Subsets (Power Set)</a> -
                  <span class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Return all possible subsets of a given set of distinct integers.
                    <br><strong>Core Idea:</strong> This is a classic backtracking problem solved
                    with recursion. The recursive function explores two choices for each number:
                    either "include" it in the current subset, or "don't include" it. You recurse on
                    both paths.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Permutations</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Return all possible permutations (re-arrangements) of a list of distinct
                    numbers. <br><strong>Core Idea:</strong> Another backtracking classic. In your
                    recursive function, you iterate through the numbers. For each number, you add it
                    to the current permutation, recursively call the function with the remaining
                    numbers, and then "backtrack" by removing the number to try the next
                    possibility.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Reverse a Linked List
                    (Recursive)</a> - <span
                    class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Reverse a linked list using recursion. <br><strong>Core Idea:</strong> The base
                    case is an empty list or a list with one node. The recursive step is: first,
                    recursively reverse the *rest* of the list (`head.next`). This returns the new
                    head of the reversed sublist. Then, re-wire the pointers: `head.next.next =
                    head` and `head.next = null`.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Merge Two Sorted
                    Lists
                    (Recursive)</a> - <span
                    class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Merge two sorted linked lists recursively. <br><strong>Core Idea:</strong> The
                    base cases are if either list is empty. Otherwise, compare the heads of the two
                    lists. The smaller node becomes the head of the merged list. Its `next` pointer
                    is the result of a recursive call to merge the *rest* of that list with the
                    other list.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Validate Binary
                    Search
                    Tree</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Determine if a binary tree is a valid BST. <br><strong>Core Idea:</strong>
                    Recursion is the most elegant solution. Create a helper function that takes a
                    node and `min` and `max` range. The base case is a null node (which is valid).
                    The recursive step checks if the current node's value is within the valid range,
                    then recursively calls on the left child with an updated `max` and the right
                    child with an updated `min`.</p>
                </li>
              </ul>
            </details>

            <div class="mt-12 flex justify-between">
              <a href="#sorting" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm"><i
                  class="fas fa-arrow-left mr-2"></i> Prev: Sorting</a>
              <a href="#backtracking" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm">Next: Backtracking
                <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
          </section>

          <section class="topic-section p-8 rounded-2xl" id="backtracking" data-aos="fade-up"
            style="border-top-color: var(--color-backtracking);">
            <h2 class="text-4xl font-bold flex items-center mb-4">
              <i class="fas fa-shoe-prints mr-4" style="color: var(--color-backtracking);"></i>Backtracking: An In-Depth
              Guide
            </h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">
              If recursion is like exploring a cave system by following every possible path,
              **Backtracking** is the intelligent version of that exploration. It's a strategy for finding
              solutions to problems with constraints by systematically exploring all potential paths, but
              with a crucial optimization: **pruning**. As soon as you realize a path cannot possibly lead
              to a valid solution, you abandon it and "backtrack" to the last decision point to try a
              different option.
            </p>

            <h3 class="text-2xl font-bold mb-3">The Core Idea: A Maze with Dead Ends</h3>
            <p class="mb-4">
              Imagine you are solving a maze. You come to a fork in the road and have to make a choice.
            </p>
            <ul class="list-disc ml-5 space-y-2 mb-6">
              <li>You **choose** a path (e.g., go left).</li>
              <li>You **explore** down that path.</li>
              <li>If you hit a dead end, you realize this path was a mistake. You **backtrack** to the
                fork where you last made a choice and try a different path (go right).</li>
            </ul>
            <p>This is the essence of backtracking. It's a form of "brute force with a brain," because it
              smartly abandons fruitless paths instead of exploring them to their bitter end.</p>


            <h3 class="text-2xl font-bold mt-8 mb-4">The Backtracking Template: Choose, Explore, Unchoose
            </h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              Almost every backtracking problem can be solved using a recursive function that follows this
              three-step pattern:
            </p>
            <div class="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg my-6 border-l-4 border-purple-500">
              <h4 class="font-bold text-lg mb-2">The General Algorithm</h4>
              <pre class="font-mono text-sm">
function backtrack(arguments...):
    if (we found a solution):
        add solution to our list
        return

    for every possible choice we can make right now:
        1. **Choose**: Make a choice (e.g., place a queen, add a number).
        2. **Explore**: Call `backtrack(updated arguments...)` to see where this choice leads.
        3. **Unchoose**: Backtrack! Undo the choice so we can try the next one.
        </pre>
            </div>
            <p>The "unchoose" step is the most critical part. It's what allows us to return to a previous
              state and explore a different set of possibilities, effectively "pruning" the decision tree.
            </p>

            <h3 class="text-2xl font-bold mt-8 mb-4">Visualizing the State-Space Tree</h3>
            <p class="mb-4">
              Backtracking explores what's known as a "state-space tree," which is a tree of all possible
              choices. Let's visualize finding all permutations of "ABC":
            </p>
            <pre class="bg-gray-100 dark:bg-gray-800 p-4 mt-2 rounded-lg font-mono text-sm">
Start: ""
|
+-- Choose 'A' -> "A"
|   |
|   +-- Choose 'B' -> "AB"
|   |   |
|   |   +-- Choose 'C' -> "ABC" (Solution!) -> Unchoose 'C'
|   |
|   +-- Choose 'C' -> "AC"
|       |
|       +-- Choose 'B' -> "ACB" (Solution!) -> Unchoose 'B'
|
+-- Choose 'B' -> "B"
|   ... (and so on)
...
    </pre>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-8 mb-4">Classic Problem: N-Queens</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              The N-Queens puzzle is the quintessential backtracking problem: Place N chess queens on an
              N×N chessboard so that no two queens threaten each other.
            </p>
            <ul class="list-disc ml-5 space-y-1 mb-4">
              <li><strong>Choose:</strong> Place a queen in a specific row and column.</li>
              <li><strong>Constraint:</strong> Is this position attacked by any previously placed queen?
                If yes, this choice is invalid.</li>
              <li><strong>Explore:</strong> If the position is safe, recursively call the function to
                place a queen in the next row.</li>
              <li><strong>Unchoose:</strong> Remove the queen from the current position to explore other
                columns in the same row.</li>
            </ul>

            <div class="code-tabs mb-2">
              <button class="tab-btn active" data-tab="nqueens-java">Java</button>
              <button class="tab-btn" data-tab="nqueens-cpp">C++</button>
              <button class="tab-btn" data-tab="nqueens-python">Python</button>
            </div>
            <!-- Java Code -->
            <div class="tab-content relative" id="nqueens-java">
              <pre><code class="language-java">// N-Queens Solver in Java
class NQueens {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> solutions = new ArrayList<>();
        char[][] board = new char[n][n];
        for (char[] row : board) Arrays.fill(row, '.');
        backtrack(solutions, board, 0);
        return solutions;
    }

    private void backtrack(List<List<String>> solutions, char[][] board, int row) {
        if (row == board.length) {
            solutions.add(createSolution(board));
            return;
        }

        for (int col = 0; col < board.length; col++) {
            if (isSafe(board, row, col)) {
                // Choose
                board[row][col] = 'Q';
                // Explore
                backtrack(solutions, board, row + 1);
                // Unchoose (Backtrack)
                board[row][col] = '.';
            }
        }
    }

    private boolean isSafe(char[][] board, int row, int col) { /* ... check columns, diagonals ... */ }
    private List<String> createSolution(char[][] board) { /* ... convert char[][] to List<String> ... */ }
}</code></pre>
            </div>
            <!-- C++ Code -->
            <div class="tab-content relative hidden" id="nqueens-cpp">
              <pre><code class="language-cpp">// N-Queens Solver in C++
#include <vector>
#include <string>

class NQueens {
public:
    std::vector<std::vector<std::string>> solveNQueens(int n) {
        std::vector<std::vector<std::string>> solutions;
        std::vector<std::string> board(n, std::string(n, '.'));
        backtrack(solutions, board, 0);
        return solutions;
    }

private:
    void backtrack(std::vector<std::vector<std::string>>& solutions, std::vector<std::string>& board, int row) {
        if (row == board.size()) {
            solutions.push_back(board);
            return;
        }

        for (int col = 0; col < board.size(); ++col) {
            if (isSafe(board, row, col)) {
                // Choose
                board[row][col] = 'Q';
                // Explore
                backtrack(solutions, board, row + 1);
                // Unchoose
                board[row][col] = '.';
            }
        }
    }

    bool isSafe(const std::vector<std::string>& board, int row, int col) { /* ... */ }
};</code></pre>
            </div>
            <!-- Python Code -->
            <div class="tab-content relative hidden" id="nqueens-python">
              <pre><code class="language-python"># N-Queens Solver in Python
class NQueens:
    def solveNQueens(self, n: int) -> list[list[str]]:
        solutions = []
        board = [['.'] * n for _ in range(n)]

        def backtrack(row):
            if row == n:
                solutions.append(["".join(r) for r in board])
                return

            for col in range(n):
                if is_safe(row, col):
                    # Choose
                    board[row][col] = 'Q'
                    # Explore
                    backtrack(row + 1)
                    # Unchoose
                    board[row][col] = '.'
        
        def is_safe(r, c):
            # ... Check columns and diagonals ...
            # For simplicity, implementation is omitted
            # In a real solution, you'd use sets or arrays to track attacked positions
            return True

        backtrack(0)
        return solutions
</code></pre>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-12 mb-4">Top 5 Interview Questions</h3>
            <details class="mt-8 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <summary class="text-xl">View Essential Backtracking Interview Questions</summary>
              <ul class="list-decimal ml-5 space-y-4 mt-4">
                <li>
                  <a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Subsets</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Return all possible subsets (the power set) of a given set of distinct integers.
                    <br><strong>Core Idea:</strong> The quintessential backtracking problem. For
                    each number, you have two choices: include it in the current subset or not. The
                    recursive function explores both branches.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Combination Sum</a> -
                  <span class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Find all unique combinations in a set of candidate numbers that sum up to a
                    target number. <br><strong>Core Idea:</strong> Similar to Subsets, but with a
                    target sum constraint. You choose a number, add it to the current combination,
                    and recurse with a reduced target. Crucially, you can reuse the same number.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Permutations</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Return all possible permutations of a list of distinct numbers. <br><strong>Core
                      Idea:</strong> In each recursive step, iterate through the numbers that
                    haven't been used yet. Choose one, add it to the current permutation, recurse,
                    and then unchoose it to try the next number.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Word Search</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given a 2D board of characters and a word, find if the word exists in the grid.
                    <br><strong>Core Idea:</strong> A DFS on a grid. Start a search from every cell.
                    The recursive function checks if the current cell matches the current letter of
                    the word. If it does, mark the cell as visited (choose), then explore all four
                    neighbors recursively. If the path doesn't lead to a solution, backtrack by
                    un-marking the cell.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/n-queens/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">N-Queens</a> - <span
                    class="text-sm font-semibold bg-red-500 text-red-100 px-2 py-1 rounded">Hard</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Place N queens on an N×N chessboard so that no two queens attack each other.
                    <br><strong>Core Idea:</strong> As shown above, you try to place a queen in each
                    row. For each column in a row, you check if placing a queen there is "safe". If
                    it is, you place it and recurse on the next row. If that path fails, you remove
                    the queen and try the next column.
                  </p>
                </li>
              </ul>
            </details>

            <div class="mt-12 flex justify-between">
              <a href="#recursion" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm"><i
                  class="fas fa-arrow-left mr-2"></i> Prev: Recursion</a>
              <a href="#dp" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm">Next: Dynamic
                Programming <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
          </section>

          <section class="topic-section p-8 rounded-2xl" id="dp" data-aos="fade-up"
            style="border-top-color: var(--color-dp);">
            <h2 class="text-4xl font-bold flex items-center mb-4">
              <i class="fas fa-brain mr-4" style="color: var(--color-dp);"></i>Dynamic Programming: An
              In-Depth Guide
            </h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">
              Dynamic Programming is a game-changing technique for solving complex problems by breaking
              them down into simpler, overlapping subproblems. It is essentially **"recursion with a
              memory."** Where a naive recursive solution might wastefully re-compute the same subproblem
              dozens of times, a DP solution solves each subproblem just once and stores the result. This
              simple idea can turn an exponential-time algorithm into a polynomial-time powerhouse.
            </p>

            <h3 class="text-2xl font-bold mb-3">The Two Hallmarks of a DP Problem</h3>
            <p class="mb-4">
              You can almost always apply DP if a problem exhibits these two properties:
            </p>
            <div class="grid md:grid-cols-2 gap-8 mt-4">
              <div>
                <h4 class="font-bold text-lg mb-2">1. Overlapping Subproblems</h4>
                <p>A problem has overlapping subproblems if it can be broken down into smaller
                  subproblems that are reused multiple times. Consider calculating `fibonacci(5)`:</p>
                <pre class="bg-gray-100 dark:bg-gray-800 p-4 mt-2 rounded-lg font-mono text-sm">
                      fib(5)
                   /         \
              fib(4)           <span class="text-red-500">fib(3)</span>
             /     \          /      \
        <span class="text-red-500">fib(3)</span>   fib(2)    fib(2)   fib(1)
       /    \    /   \
    fib(2) fib(1) fib(1) fib(0)
            </pre>
                <p class="mt-2">Notice that `fib(3)` is computed twice, and `fib(2)` is computed three
                  times. A DP solution avoids this redundant work.</p>
              </div>
              <div>
                <h4 class="font-bold text-lg mb-2">2. Optimal Substructure</h4>
                <p>A problem has optimal substructure if the optimal solution to the overall problem can
                  be constructed from the optimal solutions of its subproblems.
                  <br><br>
                  <strong>Analogy:</strong> If the shortest path from New York to Los Angeles passes
                  through Chicago, then the "New York to Chicago" part of that path *must* be the
                  shortest path from New York to Chicago. You can't have a shorter overall path by
                  taking a longer sub-path.
                </p>
              </div>
            </div>

            <h3 class="text-2xl font-bold mt-8 mb-4">The Two Techniques for Solving DP Problems</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              There are two standard ways to implement a DP solution.
            </p>

            <!-- Memoization -->
            <div class="topic-section p-6 rounded-xl border-t-4 mt-8" style="border-top-color: var(--color-dp)">
              <h4 class="text-2xl font-bold mb-3">1. Memoization (Top-Down)</h4>
              <p class="mb-4">This is the "recursion with a cheat sheet" approach. You write a standard
                recursive function, but you add a cache (like a hash map or an array) to store the
                results of each subproblem. Before computing anything, you check the cache. If the
                result is already there, you use it. If not, you compute it, store it in the cache for
                next time, and then return it.</p>
            </div>

            <!-- Tabulation -->
            <div class="topic-section p-6 rounded-xl border-t-4 mt-8" style="border-top-color: var(--color-dp)">
              <h4 class="text-2xl font-bold mb-3">2. Tabulation (Bottom-Up)</h4>
              <p class="mb-4">This is the "build it from the ground up" approach. Instead of starting from
                the top (the final problem) and recursing down, you start from the bottom (the simplest
                base cases) and solve the subproblems iteratively. You create a table (usually an array
                or a 2D grid) and fill it out, using previously computed values to find the next value,
                until you arrive at the final solution.</p>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-8 mb-4">Classic Problem: Coin Change</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              Given a set of coin denominations and a total amount, find the minimum number of coins
              required to make up that amount. We'll use the **Tabulation (Bottom-Up)** approach.
            </p>
            <p class="font-semibold">Visualizing the DP Table for `amount = 5`, `coins = [1, 2, 3]`:</p>
            <pre class="bg-gray-100 dark:bg-gray-800 p-4 mt-2 rounded-lg font-mono text-sm">
// dp[i] = min coins for amount i
dp table of size 6: [0, ?, ?, ?, ?, ?]

i=1: Can I make 1? Yes, with coin 1.
     dp[1] = min(dp[1], 1 + dp[1-1]) = 1
     Table: [0, 1, ?, ?, ?, ?]

i=2: Can I make 2? Yes, with coin 1 or 2.
     - With coin 1: 1 + dp[1] = 1 + 1 = 2
     - With coin 2: 1 + dp[0] = 1 + 0 = 1
     dp[2] = 1
     Table: [0, 1, 1, ?, ?, ?]

i=3: Can I make 3? Yes, with coin 1, 2, or 3.
     - With coin 1: 1 + dp[2] = 1 + 1 = 2
     - With coin 2: 1 + dp[1] = 1 + 1 = 2
     - With coin 3: 1 + dp[0] = 1 + 0 = 1
     dp[3] = 1
     Table: [0, 1, 1, 1, ?, ?]

...and so on until dp[5] is filled.
    </pre>

            <div class="code-tabs mb-2 mt-4">
              <button class="tab-btn active" data-tab="dp-java">Java</button>
              <button class="tab-btn" data-tab="dp-cpp">C++</button>
              <button class="tab-btn" data-tab="dp-python">Python</button>
            </div>
            <!-- Java Code -->
            <div class="tab-content relative" id="dp-java">
              <pre><code class="language-java">// Coin Change Problem in Java (Tabulation)
import java.util.Arrays;

class CoinChange {
    public int coinChange(int[] coins, int amount) {
        // dp[i] will store the minimum coins for amount i
        int[] dp = new int[amount + 1];
        // Initialize with a value larger than any possible answer
        Arrays.fill(dp, amount + 1);

        // Base case: 0 coins are needed to make amount 0
        dp[0] = 0;

        // Build the table from amount 1 to the target amount
        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {
                if (i - coin >= 0) {
                    // Recurrence relation
                    dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
                }
            }
        }

        // If dp[amount] was never updated, it's impossible
        return dp[amount] > amount ? -1 : dp[amount];
    }
}</code></pre>
            </div>
            <!-- C++ Code -->
            <div class="tab-content relative hidden" id="dp-cpp">
              <pre><code class="language-cpp">// Coin Change Problem in C++ (Tabulation)
#include <vector>
#include <algorithm>

class CoinChange {
public:
    int coinChange(std::vector<int>& coins, int amount) {
        std::vector<int> dp(amount + 1, amount + 1);
        dp[0] = 0;

        for (int i = 1; i <= amount; ++i) {
            for (int coin : coins) {
                if (i - coin >= 0) {
                    dp[i] = std::min(dp[i], 1 + dp[i - coin]);
                }
            }
        }

        return dp[amount] > amount ? -1 : dp[amount];
    }
};</code></pre>
            </div>
            <!-- Python Code -->
            <div class="tab-content relative hidden" id="dp-python">
              <pre><code class="language-python"># Coin Change Problem in Python (Tabulation)
from typing import List

class CoinChange:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # dp[i] will store the minimum coins for amount i
        # Initialize with a value larger than any possible answer
        dp = [float('inf')] * (amount + 1)
        
        # Base case
        dp[0] = 0
        
        for i in range(1, amount + 1):
            for coin in coins:
                if i - coin >= 0:
                    dp[i] = min(dp[i], 1 + dp[i - coin])
                    
        return dp[amount] if dp[amount] != float('inf') else -1
</code></pre>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-12 mb-4">Top 5 Interview Questions</h3>
            <details class="mt-8 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <summary class="text-xl">View Essential DP Interview Questions</summary>
              <ul class="list-decimal ml-5 space-y-4 mt-4">
                <li>
                  <a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Climbing Stairs</a> -
                  <span class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    You are climbing a staircase. It takes n steps to reach the top. Each time you
                    can either climb 1 or 2 steps. In how many distinct ways can you climb to the
                    top? <br><strong>Core Idea:</strong> The "Hello, World!" of DP. The number of
                    ways to get to step `n` is `ways(n-1) + ways(n-2)`. This is the Fibonacci
                    sequence in disguise.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">House Robber</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Rob houses along a street, but you cannot rob two adjacent houses. Maximize your
                    profit. <br><strong>Core Idea:</strong> For each house `i`, you have two
                    choices: rob it or don't. The max money you can get up to house `i` is
                    `max(money from robbing house i-1, money from robbing house i-2 + money at house
                    i)`.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Longest Increasing
                    Subsequence (LIS)</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Find the length of the longest subsequence of a given sequence in which all
                    elements are in increasing order. <br><strong>Core Idea:</strong> A classic
                    $O(n^2)$ DP solution where `dp[i]` represents the length of the LIS ending at
                    index `i`. To calculate `dp[i]`, you look at all previous elements `j < i` and find the one that can
                      extend the longest sequence.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Coin Change</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Find the fewest number of coins that you need to make up a certain amount.
                    <br><strong>Core Idea:</strong> As demonstrated above, this is a classic
                    "unbounded knapsack" type problem where `dp[i]` builds upon the optimal
                    solutions for smaller amounts.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Longest Common
                    Subsequence</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Find the length of the longest subsequence common to two strings.
                    <br><strong>Core Idea:</strong> The quintessential 2D DP problem. You build a
                    matrix where `dp[i][j]` is the length of the LCS for the first `i` characters of
                    `string1` and the first `j` characters of `string2`. The state transition
                    depends on whether the characters at `i` and `j` match.
                  </p>
                </li>
              </ul>
            </details>

            <div class="mt-12 flex justify-between">
              <a href="#backtracking" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm"><i
                  class="fas fa-arrow-left mr-2"></i> Prev: Backtracking</a>
              <a href="#greedy" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm">Next:
                Greedy Algorithms <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
          </section>

          <section class="topic-section p-8 rounded-2xl" id="greedy" data-aos="fade-up"
            style="border-top-color: var(--color-greedy);">
            <h2 class="text-4xl font-bold flex items-center mb-4">
              <i class="fas fa-coins mr-4" style="color: var(--color-greedy);"></i>Greedy Algorithms: An
              In-Depth Guide
            </h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">
              The Greedy method is one of the most straightforward algorithmic strategies. It's an
              approach for solving optimization problems by making the choice that seems best at the
              current moment, without considering the future consequences. It follows the philosophy of
              "take the best you can get right now." While this sounds simple, it only works for a special
              class of problems where a series of locally optimal choices leads to a globally optimal
              solution.
            </p>

            <h3 class="text-2xl font-bold mb-3">The Core Idea: The Impatient Traveler</h3>
            <p class="mb-4">
              Imagine you are a traveler trying to get from one city to another, and at every
              intersection, you take the road that looks like the most direct route towards your
              destination. You don't look at a map or consider that a slightly longer road now might save
              you from a huge traffic jam later. You make the **locally optimal choice** (the road that
              points most directly to the destination) at each step, hoping it will lead to the **globally
              optimal solution** (the fastest overall route).
            </p>

            <h3 class="text-2xl font-bold mt-8 mb-4">When Does a Greedy Strategy Work?</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              A greedy algorithm is only guaranteed to be correct for problems that have two key
              properties:
            </p>
            <div class="grid md:grid-cols-2 gap-8 mt-4">
              <div>
                <h4 class="font-bold text-lg mb-2">1. Greedy Choice Property</h4>
                <p>This is the big one. It means that a globally optimal solution can be arrived at by
                  making a locally optimal choice. In our traveler analogy, this property would only
                  hold if the most direct-looking road at every intersection was *always* part of the
                  actual fastest route. You can make the "best" choice right now and never have to
                  reconsider it.</p>
              </div>
              <div>
                <h4 class="font-bold text-lg mb-2">2. Optimal Substructure</h4>
                <p>This property (which it shares with Dynamic Programming) means that an optimal
                  solution to the overall problem contains within it optimal solutions to subproblems.
                  For our traveler, if the fastest route from A to C goes through B, then the path
                  from A to B within that route must be the fastest path from A to B.</p>
              </div>
            </div>

            <div
              class="bg-yellow-100 dark:bg-yellow-900 border-l-4 border-yellow-500 text-yellow-700 dark:text-yellow-200 p-4 rounded my-8">
              <p class="font-bold">Greedy vs. Dynamic Programming</p>
              <p>A DP solution makes a decision based on the solutions to all its subproblems. A Greedy
                algorithm makes one locally optimal choice and then solves the single subproblem that
                remains. It never looks back.</p>
            </div>

            <h3 class="text-2xl font-bold mt-8 mb-4">Classic Problem: Activity Selection (Interval
              Scheduling)</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              This is the quintessential problem where a greedy strategy shines. Given a set of activities
              with start and finish times, select the maximum number of non-overlapping activities that
              can be performed by a single person.
            </p>
            <p class="mb-2"><strong>The Greedy Choice:</strong> Sort the activities by their **finish
              times**. Then, always choose the next activity whose start time is after the finish time of
              the last chosen activity.</p>
            <p><strong>Why it works:</strong> By picking the activity that finishes earliest, you free up
              your time as quickly as possible, maximizing the opportunity to fit in subsequent
              activities.</p>

            <div class="code-tabs mb-2 mt-4">
              <button class="tab-btn active" data-tab="greedy-java">Java</button>
              <button class="tab-btn" data-tab="greedy-cpp">C++</button>
              <button class="tab-btn" data-tab="greedy-python">Python</button>
            </div>
            <!-- Java Code -->
            <div class="tab-content relative" id="greedy-java">
              <pre><code class="language-java">// Activity Selection Problem in Java
import java.util.Arrays;
import java.util.Comparator;

class Activity {
    int start, finish;
    Activity(int start, int finish) { this.start = start; this.finish = finish; }
}

class ActivitySelection {
    public static int maxActivities(Activity[] arr) {
        // Sort activities by finish time
        Arrays.sort(arr, Comparator.comparingInt(a -> a.finish));
        
        int count = 1; // The first activity is always selected
        int lastFinishTime = arr[0].finish;
        
        for (int i = 1; i < arr.length; i++) {
            // If this activity has a start time after the last one finished
            if (arr[i].start >= lastFinishTime) {
                count++;
                lastFinishTime = arr[i].finish;
            }
        }
        return count;
    }
}</code></pre>
            </div>
            <!-- C++ Code -->
            <div class="tab-content relative hidden" id="greedy-cpp">
              <pre><code class="language-cpp">// Activity Selection Problem in C++
#include <iostream>
#include <vector>
#include <algorithm>

struct Activity {
    int start, finish;
};

bool compareActivities(Activity a, Activity b) {
    return (a.finish < b.finish);
}

int maxActivities(std::vector<Activity>& arr) {
    // Sort activities by finish time
    std::sort(arr.begin(), arr.end(), compareActivities);

    int count = 1; // The first activity is always selected
    int lastFinishTime = arr[0].finish;

    for (int i = 1; i < arr.size(); i++) {
        if (arr[i].start >= lastFinishTime) {
            count++;
            lastFinishTime = arr[i].finish;
        }
    }
    return count;
}</code></pre>
            </div>
            <!-- Python Code -->
            <div class="tab-content relative hidden" id="greedy-python">
              <pre><code class="language-python"># Activity Selection Problem in Python
def max_activities(activities):
    """activities is a list of tuples (start_time, finish_time)"""
    # Sort activities by finish time (the second element of the tuple)
    activities.sort(key=lambda x: x[1])
    
    count = 1
    # The first activity is always selected
    last_finish_time = activities[0][1]
    
    for i in range(1, len(activities)):
        start_time, finish_time = activities[i]
        # If this activity starts after the last one finished
        if start_time >= last_finish_time:
            count += 1
            last_finish_time = finish_time
            
    return count
</code></pre>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-12 mb-4">Top 5 Interview Questions</h3>
            <details class="mt-8 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <summary class="text-xl">View Essential Greedy Interview Questions</summary>
              <ul class="list-decimal ml-5 space-y-4 mt-4">
                <li>
                  <a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Jump Game</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    You are at the first index of an array of jump lengths. Can you reach the last
                    index? <br><strong>Greedy Choice:</strong> At each step, find the furthest you
                    can possibly reach. Keep track of a `max_reach` variable. If your current
                    position ever exceeds `max_reach`, you're stuck.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Gas Station</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given gas stations on a circular route, find the starting station from which you
                    can complete a full circle. <br><strong>Greedy Choice:</strong> If the total gas
                    is less than the total cost, it's impossible. Otherwise, a solution is
                    guaranteed. Start a trip from station 0. If you run out of gas at station `j`,
                    you know that no station from 0 to `j` could have been the start. So, the new
                    potential start is `j+1`.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Merge Intervals</a> -
                  <span class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Merge all overlapping intervals. <br><strong>Greedy Choice:</strong> First, sort
                    the intervals by their start time. This is the crucial greedy step. Then,
                    iterate through the sorted intervals. If the current interval overlaps with the
                    last one in your result list, merge them by updating the end time. Otherwise,
                    add the new interval.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/task-scheduler/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Task Scheduler</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Schedule tasks with a cooldown period between identical tasks to minimize total
                    time. <br><strong>Greedy Choice:</strong> At each step, schedule the most
                    frequent task that is currently available (not on cooldown). This ensures you
                    are always reducing the count of the most "problematic" task, creating idle
                    slots that can be filled by other tasks.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/partition-labels/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Partition Labels</a> -
                  <span class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Partition a string into as many parts as possible such that each letter appears
                    in at most one part. <br><strong>Greedy Choice:</strong> First, find the last
                    occurrence of every character. Then, iterate through the string, maintaining an
                    `end` pointer for the current partition. For each character, update `end` to be
                    the maximum of its current value and the last occurrence of that character. A
                    partition can be closed when your iteration index reaches `end`.</p>
                </li>
              </ul>
            </details>

            <div class="mt-12 flex justify-between">
              <a href="#dp" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm"><i
                  class="fas fa-arrow-left mr-2"></i> Prev: Dynamic Programming</a>
              <a href="#advancedtrees" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm">Next: Advanced
                Trees <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
          </section>

          <section class="topic-section p-8 rounded-2xl" id="advancedtrees" data-aos="fade-up"
            style="border-top-color: var(--color-advancedtrees);">
            <h2 class="text-4xl font-bold flex items-center mb-4">
              <i class="fas fa-sitemap mr-4" style="color: var(--color-advancedtrees);"></i>Advanced
              Trees: An In-Depth Guide
            </h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">
              While the Binary Search Tree is a powerful concept, it has a fatal flaw: it can become
              **unbalanced**. If you insert sorted data (e.g., 1, 2, 3, 4, 5) into a naive BST, it
              degenerates into a linked list, and its performance plummets from $O(\log n)$ to $O(n)$.
              Advanced trees are designed to solve this problem and others by enforcing specific
              structural rules.
            </p>

            <!-- ======================================================================= -->
            <!-- ======================= SELF-BALANCING TREES ========================== -->
            <!-- ======================================================================= -->
            <div class="topic-section p-6 rounded-xl border-t-4 mt-8"
              style="border-top-color: var(--color-advancedtrees)">
              <h3 class="text-2xl font-bold mb-3">1. The Concept: Self-Balancing BSTs (AVL & Red-Black
                Trees)</h3>
              <p class="mb-2"><strong>Analogy:</strong> A self-organizing bookshelf. Every time you add or
                remove a book, a mechanism automatically shuffles other books to ensure the shelf
                remains stable and balanced, keeping search times low for everyone.</p>
              <p class="mb-4">Self-Balancing BSTs are designed to automatically maintain a balanced
                height. After every insertion or deletion, they perform checks and use a clever
                mechanism called **rotations** to re-arrange nodes, guaranteeing that the tree's height
                remains logarithmic in the number of nodes. This preserves the $O(\log n)$ performance
                for all major operations.</p>

              <div class="grid md:grid-cols-2 gap-8 items-center">
                <div>
                  <p class="font-semibold">Unbalanced vs. Balanced:</p>
                  <pre class="bg-gray-100 dark:bg-gray-800 p-4 mt-2 rounded-lg font-mono text-sm">
Unbalanced (like a list):
1
 \
  2
   \
    3
     \
      4
      
Balanced (ideal search):
    2
   / \
  1   3
       \
        4
                </pre>
                </div>
                <div>

                  <p class="text-sm text-gray-500 mt-2">The balanced tree has a much shorter height,
                    leading to faster searches.</p>
                </div>
              </div>

              <p class="mt-4"><strong>Famous Examples:</strong> AVL Trees (stricter balancing) and
                Red-Black Trees (used in C++ `std::map` and Java's `TreeMap`). You are rarely asked to
                implement their complex balancing logic in an interview, but you **must** know what they
                are and why they are used.</p>
            </div>

            <!-- ======================================================================= -->
            <!-- ======================= HEAPS (PRIORITY QUEUES) ======================= -->
            <!-- ======================================================================= -->
            <div class="topic-section p-6 rounded-xl border-t-4 mt-8"
              style="border-top-color: var(--color-advancedtrees)">
              <h3 class="text-2xl font-bold mb-3">2. The Heap: The Priority Manager</h3>
              <p class="mb-2"><strong>Analogy:</strong> An emergency room triage. Patients are not treated
                in the order they arrive (FIFO), but by the severity of their condition. A Heap is a
                data structure that allows you to efficiently find and remove the highest-priority item.
              </p>
              <p class="mb-4">A Heap is a specialized tree-based structure that satisfies the **Heap
                Property**. The two main types are:</p>
              <ul class="list-disc ml-5 space-y-1 mb-4">
                <li><strong>Max-Heap:</strong> The value of each node is greater than or equal to the
                  value of its children. The root is the maximum element.</li>
                <li><strong>Min-Heap:</strong> The value of each node is less than or equal to the value
                  of its children. The root is the minimum element.</li>
              </ul>
              <p>A heap is always a **complete binary tree**, meaning all levels are fully filled except
                possibly the last, which is filled from left to right. This allows it to be efficiently
                represented by a simple array, making it very space-efficient.</p>

              <div class="code-tabs mb-2 mt-4">
                <button class="tab-btn active" data-tab="heap-java">Java</button>
                <button class="tab-btn" data-tab="heap-cpp">C++</button>
                <button class="tab-btn" data-tab="heap-python">Python</button>
              </div>
              <div class="tab-content relative" id="heap-java">
                <pre><code class="language-java">// Java's PriorityQueue is a Min-Heap by default
import java.util.PriorityQueue;
import java.util.Collections;

// Min-Heap
PriorityQueue<Integer> minHeap = new PriorityQueue<>();
minHeap.add(10);
minHeap.add(30);
minHeap.add(20);
System.out.println(minHeap.peek()); // Prints 10

// Max-Heap (use a reverse order comparator)
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
maxHeap.add(10);
maxHeap.add(30);
maxHeap.add(20);
System.out.println(maxHeap.peek()); // Prints 30
</code></pre>
              </div>
              <div class="tab-content relative hidden" id="heap-cpp">
                <pre><code class="language-cpp">// C++'s priority_queue is a Max-Heap by default
#include <iostream>
#include <queue>
#include <vector>

// Max-Heap
std::priority_queue<int> maxHeap;
maxHeap.push(10);
maxHeap.push(30);
maxHeap.push(20);
std::cout << maxHeap.top() << std::endl; // Prints 30

// Min-Heap (requires a custom comparator)
std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
minHeap.push(10);
minHeap.push(30);
minHeap.push(20);
std::cout << minHeap.top() << std::endl; // Prints 10
</code></pre>
              </div>
              <div class="tab-content relative hidden" id="heap-python">
                <pre><code class="language-python"># Python's heapq module implements a Min-Heap
import heapq

min_heap = []
heapq.heappush(min_heap, 10)
heapq.heappush(min_heap, 30)
heapq.heappush(min_heap, 20)
print(min_heap[0]) # Prints 10

# Max-Heap (trick: store negated values in a min-heap)
max_heap = []
heapq.heappush(max_heap, -10)
heapq.heappush(max_heap, -30)
heapq.heappush(max_heap, -20)
print(-max_heap[0]) # Prints 30
</code></pre>
              </div>
            </div>

            <!-- ======================================================================= -->
            <!-- ======================= TRIES (PREFIX TREES) ========================== -->
            <!-- ======================================================================= -->
            <div class="topic-section p-6 rounded-xl border-t-4 mt-8"
              style="border-top-color: var(--color-advancedtrees)">
              <h3 class="text-2xl font-bold mb-3">3. The Trie (Prefix Tree): The Dictionary Master</h3>
              <p class="mb-2"><strong>Analogy:</strong> A search engine's autocomplete feature. As you
                type "ca", it suggests "car", "cat", and "castle". A Trie is the data structure that
                powers this lightning-fast prefix-based searching.</p>
              <p class="mb-4">A Trie is a special tree used for storing and retrieving strings. Each node
                represents a single character. A path from the root to a node represents a prefix. A
                special boolean flag on a node marks the end of a complete, valid word.</p>

              <div class="code-tabs mb-2 mt-4">
                <button class="tab-btn active" data-tab="trie-java">Java</button>
                <button class="tab-btn" data-tab="trie-cpp">C++</button>
                <button class="tab-btn" data-tab="trie-python">Python</button>
              </div>
              <div class="tab-content relative" id="trie-java">
                <pre><code class="language-java">// Trie in Java
class TrieNode {
    TrieNode[] children = new TrieNode[26];
    boolean isEndOfWord = false;
}

class Trie {
    TrieNode root = new TrieNode();

    public void insert(String word) {
        TrieNode current = root;
        for (char ch : word.toCharArray()) {
            if (current.children[ch - 'a'] == null) {
                current.children[ch - 'a'] = new TrieNode();
            }
            current = current.children[ch - 'a'];
        }
        current.isEndOfWord = true;
    }

    public boolean search(String word) {
        TrieNode current = root;
        for (char ch : word.toCharArray()) {
            current = current.children[ch - 'a'];
            if (current == null) return false;
        }
        return current.isEndOfWord;
    }
}</code></pre>
              </div>
              <div class="tab-content relative hidden" id="trie-cpp">
                <pre><code class="language-cpp">// Trie in C++
#include <string>
#include <vector>

struct TrieNode {
    TrieNode* children[26];
    bool isEndOfWord;
    TrieNode() {
        isEndOfWord = false;
        for (int i = 0; i < 26; i++) children[i] = nullptr;
    }
};

class Trie {
public:
    TrieNode* root = new TrieNode();
    void insert(std::string word) {
        TrieNode* current = root;
        for (char ch : word) {
            int index = ch - 'a';
            if (!current->children[index]) {
                current->children[index] = new TrieNode();
            }
            current = current->children[index];
        }
        current->isEndOfWord = true;
    }

    bool search(std::string word) {
        TrieNode* current = root;
        for (char ch : word) {
            int index = ch - 'a';
            if (!current->children[index]) return false;
            current = current->children[index];
        }
        return current && current->isEndOfWord;
    }
};</code></pre>
              </div>
              <div class="tab-content relative hidden" id="trie-python">
                <pre><code class="language-python"># Trie in Python
class TrieNode:
    def __init__(self):
        self.children = {} # A dictionary for children
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        current = self.root
        for char in word:
            if char not in current.children:
                current.children[char] = TrieNode()
            current = current.children[char]
        current.is_end_of_word = True

    def search(self, word: str) -> bool:
        current = self.root
        for char in word:
            if char not in current.children:
                return False
            current = current.children[char]
        return current.is_end_of_word
</code></pre>
              </div>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-12 mb-4">Top 5 Interview Questions</h3>
            <details class="mt-8 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <summary class="text-xl">View Essential Advanced Tree Interview Questions</summary>
              <ul class="list-decimal ml-5 space-y-4 mt-4">
                <li>
                  <a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Kth Largest Element
                    in a
                    Stream</a> - <span
                    class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Design a class to find the kth largest element in a stream of numbers.
                    <br><strong>Core Idea:</strong> The perfect use case for a Min-Heap. Maintain a
                    min-heap of size `k`. When a new number arrives, add it to the heap. If the
                    heap's size exceeds `k`, remove the minimum element. The top of the heap is
                    always the kth largest element seen so far.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Find Median from
                    Data
                    Stream</a> - <span
                    class="text-sm font-semibold bg-red-500 text-red-100 px-2 py-1 rounded">Hard</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Design a data structure that supports adding numbers and finding the median
                    efficiently. <br><strong>Core Idea:</strong> The classic two-heap solution. Use
                    a Max-Heap to store the smaller half of the numbers and a Min-Heap to store the
                    larger half. Keep the heaps balanced in size. The median is either the top of
                    the larger heap (if sizes are unequal) or the average of the tops of both heaps.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Implement Trie
                    (Prefix
                    Tree)</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Implement the Trie data structure with `insert`, `search`, and `startsWith`
                    methods. <br><strong>Core Idea:</strong> A direct implementation question to
                    test your understanding of the TrieNode structure and traversal logic, as shown
                    in the code above.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Word Search II</a> - <span
                    class="text-sm font-semibold bg-red-500 text-red-100 px-2 py-1 rounded">Hard</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given a 2D board and a list of words, find all words from the list that can be
                    formed in the grid. <br><strong>Core Idea:</strong> A brilliant combination of a
                    Trie and Backtracking/DFS. First, insert all words into a Trie. Then, perform a
                    DFS from every cell in the grid. In your DFS, you traverse the Trie
                    simultaneously as you traverse the grid. This prunes the search space massively
                    compared to searching for each word individually.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Balanced Binary
                    Tree</a> -
                  <span class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Determine if a binary tree is height-balanced (the depth of the two subtrees of
                    every node never differs by more than one). <br><strong>Core Idea:</strong> This
                    tests your understanding of the *concept* of balancing. Use a recursive DFS
                    function that returns the height of a subtree. As a special signal, if a subtree
                    is found to be unbalanced, it can return -1. The parent node can then check for
                    this -1 signal and immediately know the entire tree is unbalanced, avoiding
                    further computation.</p>
                </li>
              </ul>
            </details>

            <div class="mt-12 flex justify-between">
              <a href="#greedy" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm"><i
                  class="fas fa-arrow-left mr-2"></i> Prev: Greedy Algorithms</a>
              <a href="#dsu" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm">Next:
                Disjoint Set Union <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
          </section>

          <section class="topic-section p-8 rounded-2xl" id="dsu" data-aos="fade-up"
            style="border-top-color: var(--color-dsu);">
            <h2 class="text-4xl font-bold flex items-center mb-4">
              <i class="fas fa-object-group mr-4" style="color: var(--color-dsu);"></i>Disjoint Set Union
              (DSU): An In-Depth Guide
            </h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">
              The Disjoint Set Union (DSU) is a specialized data structure with a singular, powerful
              purpose: to keep track of a partition of a set into disjoint (non-overlapping) subsets. It
              is optimized for two operations: quickly determining which subset an element belongs to
              (**Find**) and merging two subsets together (**Union**). It is the backbone of many advanced
              graph algorithms and network connectivity problems.
            </p>

            <h3 class="text-2xl font-bold mb-3">The Core Idea: Grouping Friends</h3>
            <p class="mb-4">
              Imagine a new social network. Initially, every person is in their own group of one. When two
              people become friends, we merge their groups. Over time, large groups of interconnected
              friends form. The DSU answers two questions with incredible speed:
            </p>
            <ul class="list-disc ml-5 space-y-2 mb-6">
              <li>"Which group does this person belong to?" (**Find**)</li>
              <li>"Are these two people in the same group of friends?" (**Find** on both and compare
                results)</li>
              <li>"These two people just became friends, merge their groups." (**Union**)</li>
            </ul>
            <p>Internally, each group (or set) is represented as a tree, with one element designated as the
              **representative** (or parent) of the set—the root of the tree.</p>

            <h3 class="text-2xl font-bold mt-8 mb-4">The Naive Approach and Its Flaw</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              A simple way to implement DSU is with an array, where `parent[i]` stores the parent of
              element `i`. To `find` the representative of an element, you traverse up the parent pointers
              until you reach a node that is its own parent (the root). To `union` two sets, you simply
              set the representative of one tree as the parent of the other.
            </p>
            <p class="mb-4"><strong>The Flaw:</strong> This can lead to long, skinny trees that look like
              linked lists. In this worst-case scenario, the `find` operation degrades to $O(n)$, making
              the structure inefficient.</p>

            <h3 class="text-2xl font-bold mt-8 mb-4">The Magic: Two Crucial Optimizations</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">
              Two optimizations transform DSU from a slow, theoretical structure into one of the fastest
              data structures in existence, with nearly constant-time operations.
            </p>
            <div class="grid md:grid-cols-2 gap-8 mt-4">
              <div>
                <h4 class="font-bold text-lg mb-2">1. Path Compression</h4>
                <p>During a `find` operation, after we locate the root of the set, we re-trace our steps
                  and make every node on the path point **directly** to the root. This dramatically
                  flattens the tree for all future operations involving those nodes.</p>

              </div>
              <div>
                <h4 class="font-bold text-lg mb-2">2. Union by Rank / Size</h4>
                <p>When merging two sets, we need a smart strategy. Instead of arbitrarily connecting
                  them, we always attach the root of the **smaller** tree to the root of the
                  **larger** tree. This helps keep the trees short and bushy, preventing the
                  degenerate linked-list case. We can track the "size" (number of nodes) or "rank"
                  (height) of each tree to make this decision.</p>
              </div>
            </div>
            <p class="mt-4 font-semibold">When combined, these optimizations result in an amortized time
              complexity of nearly constant time, formally known as $O(\alpha(n))$, where $\alpha(n)$ is
              the Inverse Ackermann function. For any conceivable input size, this value is less than 5.
            </p>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-8 mb-4">DSU Code Implementation (Optimized)</h3>
            <div class="code-tabs mb-2">
              <button class="tab-btn active" data-tab="dsu-java">Java</button>
              <button class="tab-btn" data-tab="dsu-cpp">C++</button>
              <button class="tab-btn" data-tab="dsu-python">Python</button>
            </div>
            <!-- Java Code -->
            <div class="tab-content relative" id="dsu-java">
              <pre><code class="language-java">// DSU in Java with Path Compression and Union by Size
class DSU {
    private int[] parent;
    private int[] size;

    public DSU(int n) {
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i; // Each node is its own parent initially
            size[i] = 1;   // Each set has size 1 initially
        }
    }

    // Find with Path Compression
    public int find(int i) {
        if (parent[i] == i) {
            return i;
        }
        // Compress the path
        parent[i] = find(parent[i]);
        return parent[i];
    }

    // Union by Size
    public void union(int i, int j) {
        int rootI = find(i);
        int rootJ = find(j);
        if (rootI != rootJ) {
            // Attach smaller tree to the root of the larger tree
            if (size[rootI] < size[rootJ]) {
                parent[rootI] = rootJ;
                size[rootJ] += size[rootI];
            } else {
                parent[rootJ] = rootI;
                size[rootI] += size[rootJ];
            }
        }
    }
}</code></pre>
            </div>
            <!-- C++ Code -->
            <div class="tab-content relative hidden" id="dsu-cpp">
              <pre><code class="language-cpp">// DSU in C++ with Path Compression and Union by Size
#include <vector>

class DSU {
private:
    std::vector<int> parent;
    std::vector<int> sz; // 'sz' is a common name for size in C++ DSU

public:
    DSU(int n) {
        parent.resize(n);
        sz.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    int find(int i) {
        if (parent[i] == i)
            return i;
        return parent[i] = find(parent[i]); // Path compression
    }

    void unite(int i, int j) {
        int root_i = find(i);
        int root_j = find(j);
        if (root_i != root_j) {
            if (sz[root_i] < sz[root_j])
                std::swap(root_i, root_j);
            parent[root_j] = root_i;
            sz[root_i] += sz[root_j];
        }
    }
};</code></pre>
            </div>
            <!-- Python Code -->
            <div class="tab-content relative hidden" id="dsu-python">
              <pre><code class="language-python"># DSU in Python with Path Compression and Union by Size
class DSU:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n

    def find(self, i):
        if self.parent[i] == i:
            return i
        # Path compression
        self.parent[i] = self.find(self.parent[i])
        return self.parent[i]

    def union(self, i, j):
        root_i = self.find(i)
        root_j = self.find(j)
        if root_i != root_j:
            # Union by size
            if self.size[root_i] < self.size[root_j]:
                root_i, root_j = root_j, root_i # Ensure root_i is larger
            self.parent[root_j] = root_i
            self.size[root_i] += self.size[root_j]
</code></pre>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-12 mb-4">Top 5 Interview Questions</h3>
            <details class="mt-8 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <summary class="text-xl">View Essential DSU Interview Questions</summary>
              <ul class="list-decimal ml-5 space-y-4 mt-4">
                <li>
                  <a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/"
                    target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Number of Connected
                    Components</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given a number of nodes and a list of edges, find the number of connected
                    components. <br><strong>Core Idea:</strong> The canonical DSU problem.
                    Initialize a DSU with `n` components. For each edge `(u, v)`, perform a
                    `union(u, v)`. If the `union` operation results in a merge (i.e., they weren't
                    already connected), decrement your component count.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/redundant-connection/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Redundant
                    Connection</a> -
                  <span class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong> A
                    graph that was a tree has one extra edge added. Find this redundant edge.
                    <br><strong>Core Idea:</strong> This is cycle detection. Iterate through the
                    edges. For each edge `(u, v)`, check if `u` and `v` are already in the same set
                    using `find()`. If they are, this edge is redundant because it connects two
                    already-connected nodes, forming a cycle. If not, `union(u, v)`.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/accounts-merge/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Accounts Merge</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given a list of accounts with names and emails, merge accounts that share a
                    common email. <br><strong>Core Idea:</strong> The items you are "unioning" are
                    the emails. Create a mapping from each email to an ID. Then iterate through the
                    accounts, and for each account, `union` all of its emails together. Finally,
                    group the emails by their representative parent to form the merged accounts.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/number-of-provinces/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Number of Provinces</a> -
                  <span class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given an adjacency matrix representing cities, find the number of provinces
                    (groups of connected cities). <br><strong>Core Idea:</strong> This is identical
                    to "Number of Connected Components" but with a different input format.
                    Initialize a DSU with `n` cities and a province count of `n`. Iterate through
                    the matrix, and if `matrix[i][j] == 1`, perform a `union(i, j)` and decrement
                    the province count if they weren't already connected.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/satisfiability-of-equality-equations/" target="_blank"
                    rel="noopener noreferrer" class="text-indigo-500 hover:underline font-semibold">Satisfiability of
                    Equality
                    Equations</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given equations like "a==b" and "b!=c", determine if they are all satisfiable.
                    <br><strong>Core Idea:</strong> Use DSU to group all variables that must be
                    equal. Process all the "==" equations first, calling `union()` on the variables.
                    Then, process the "!=" equations. For each "a!=b", if `find(a)` is the same as
                    `find(b)`, it's a contradiction, and the equations are unsatisfiable.
                  </p>
                </li>
              </ul>
            </details>

            <div class="mt-12 flex justify-between">
              <a href="#advancedtrees" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm"><i
                  class="fas fa-arrow-left mr-2"></i> Prev: Advanced Trees</a>
              <a href="#hashing" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm">Next:
                Hashing <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
          </section>

          <section class="topic-section p-8 rounded-2xl" id="hashing" data-aos="fade-up"
            style="border-top-color: var(--color-hashing);">
            <h2 class="text-4xl font-bold flex items-center mb-4">
              <i class="fas fa-hashtag mr-4" style="color: var(--color-hashing);"></i>Hashing: The
              Ultimate Guide to Instant Lookups
            </h2>
            <p class="text-lg mb-6 text-gray-600 dark:text-gray-400">
              Imagine you have a massive library with millions of books, but instead of a card catalog,
              you have a magical librarian. You can ask for any book by its title, and she can instantly
              tell you its exact shelf and position without searching. This is the power of **Hashing**.
              It's a technique used to map data of any size (keys) to a fixed-size table (an array),
              enabling incredibly fast, near-constant time retrieval.
            </p>

            <h3 class="text-2xl font-bold mb-3">The Three Pillars of Hashing</h3>
            <p class="mb-4">
              Hashing is not a single data structure, but a process that relies on three core components
              working together.
            </p>
            <div class="space-y-6">
              <div>
                <h4 class="text-xl font-semibold">1. The Hash Function: The Magical Indexer</h4>
                <p>A hash function is a special mathematical function that takes an input key (e.g., a
                  string like "apple") and converts it into an integer index. This index tells us
                  where to store the data in our underlying array. A good hash function must be:</p>
                <ul class="list-disc ml-5 mt-2 space-y-1">
                  <li><strong>Deterministic:</strong> The same key must always produce the same hash
                    value.</li>
                  <li><strong>Fast:</strong> It must compute the index very quickly, ideally in $O(1)$
                    time.</li>
                  <li><strong>Uniform:</strong> It should distribute keys as evenly as possible across
                    the array to avoid clumping.</li>
                </ul>
              </div>
              <div>
                <h4 class="text-xl font-semibold">2. The Hash Table: The Array of Buckets</h4>
                <p>This is the underlying data structure, typically a simple array. Each slot in the
                  array is called a **bucket** or **slot**. The hash function's output is an index
                  that maps a key directly to one of these buckets.</p>
              </div>
              <div>
                <h4 class="text-xl font-semibold">3. Collision Resolution: Handling Duplicates</h4>
                <p>What happens if two different keys (e.g., "apple" and "banana") produce the same hash
                  index? This is called a **collision**, and it's inevitable. A good hashing system
                  must have a robust strategy for handling collisions.</p>
              </div>
            </div>

            <h3 class="text-2xl font-bold mt-8 mb-4">Collision Resolution Strategies</h3>
            <div class="grid md:grid-cols-2 gap-8 mt-4">
              <div>
                <h4 class="font-bold text-lg mb-2">1. Separate Chaining</h4>
                <p><strong>Analogy:</strong> A coat check with numbered hooks. If two people have the
                  same hook number, you don't turn one away. You simply hang both coats on the same
                  hook, creating a small chain of coats.</p>
                <p class="mt-2">This is the most common method. Each bucket in the array doesn't store a
                  single value, but rather a pointer to another data structure, usually a **linked
                  list**, containing all the values that hashed to that index.</p>
                <pre class="bg-gray-100 dark:bg-gray-800 p-4 mt-2 rounded-lg font-mono text-sm">
Index |
------|-------------------
  0   | -> null
  1   | -> ("apple", v1) -> ("plum", v4) -> null
  2   | -> ("banana", v2) -> null
  3   | -> ("grape", v3) -> null
            </pre>
              </div>
              <div>
                <h4 class="font-bold text-lg mb-2">2. Open Addressing (e.g., Linear Probing)</h4>
                <p><strong>Analogy:</strong> The same coat check, but with a rule: only one coat per
                  hook. If your assigned hook is taken, you "probe" for the next available empty hook
                  and hang your coat there.</p>
                <p class="mt-2">In this method, all data is stored directly within the array. If a
                  bucket is occupied, the algorithm checks the next bucket (`index + 1`), then the one
                  after that, until an empty slot is found. This is simple but can lead to
                  "clustering," where long runs of occupied slots slow down future operations.</p>
              </div>
            </div>

            <div
              class="bg-blue-100 dark:bg-blue-900 border-l-4 border-blue-500 text-blue-700 dark:text-blue-200 p-4 rounded my-8">
              <p class="font-bold">The Performance Goal: Average Case $O(1)$</p>
              <p>With a good hash function and an effective collision strategy, the number of items in any
                single bucket remains small. This means that insertion, deletion, and lookup operations
                in a Hash Map (or Hash Table) are, on average, performed in **constant time**. However,
                in the absolute worst case (where all keys hash to the same index), performance degrades
                to $O(n)$ as you search through a long linked list.</p>
            </div>

            <h3 class="text-2xl font-bold mt-8 mb-4">Using Hash Maps in Practice</h3>
            <p class="mb-4 text-gray-600 dark:text-gray-400">You will almost never implement a hash table
              from scratch. Instead, you'll use your language's highly optimized built-in version.</p>

            <div class="code-tabs mb-2">
              <button class="tab-btn active" data-tab="hash-java">Java</button>
              <button class="tab-btn" data-tab="hash-cpp">C++</button>
              <button class="tab-btn" data-tab="hash-python">Python</button>
            </div>
            <!-- Java Code -->
            <div class="tab-content relative" id="hash-java">
              <pre><code class="language-java">// Java: HashMap and HashSet
import java.util.HashMap;
import java.util.Map;
import java.util.HashSet;
import java.util.Set;

// HashMap (Key-Value pairs)
Map<String, Integer> userScores = new HashMap<>();
userScores.put("Alice", 100); // Insert/Update
userScores.put("Bob", 85);
int alicesScore = userScores.get("Alice"); // Get
userScores.remove("Bob"); // Remove
boolean hasAlice = userScores.containsKey("Alice"); // Check for key

// HashSet (Unique values)
Set<String> uniqueUsers = new HashSet<>();
uniqueUsers.add("Alice");
uniqueUsers.add("Bob");
uniqueUsers.add("Alice"); // This is ignored
boolean isMember = uniqueUsers.contains("Charlie"); // Check for value
</code></pre>
            </div>
            <!-- C++ Code -->
            <div class="tab-content relative hidden" id="hash-cpp">
              <pre><code class="language-cpp">// C++: std::unordered_map and std::unordered_set
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <string>

// unordered_map (Key-Value pairs)
std::unordered_map<std::string, int> userScores;
userScores["Alice"] = 100; // Insert/Update
userScores["Bob"] = 85;
int alicesScore = userScores["Alice"]; // Get
userScores.erase("Bob"); // Remove
bool hasAlice = userScores.count("Alice") > 0; // Check

// unordered_set (Unique values)
std::unordered_set<std::string> uniqueUsers;
uniqueUsers.insert("Alice");
uniqueUsers.insert("Bob");
uniqueUsers.insert("Alice"); // Ignored
bool isMember = uniqueUsers.count("Charlie") > 0; // Check
</code></pre>
            </div>
            <!-- Python Code -->
            <div class="tab-content relative hidden" id="hash-python">
              <pre><code class="language-python"># Python: Dictionary and Set
# Dictionary (Key-Value pairs)
user_scores = {}
user_scores["Alice"] = 100  # Insert/Update
user_scores["Bob"] = 85
alices_score = user_scores["Alice"] # Get
del user_scores["Bob"] # Remove
has_alice = "Alice" in user_scores # Check

# Set (Unique values)
unique_users = set()
unique_users.add("Alice")
unique_users.add("Bob")
unique_users.add("Alice") # Ignored
is_member = "Charlie" in unique_users # Check
</code></pre>
            </div>

            <hr class="my-12">

            <h3 class="text-2xl font-bold mt-12 mb-4">Top 5 Interview Questions</h3>
            <details class="mt-8 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <summary class="text-xl">View Essential Hashing Interview Questions</summary>
              <ul class="list-decimal ml-5 space-y-4 mt-4">
                <li>
                  <a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Two Sum</a> - <span
                    class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Find two numbers in an array that add up to a specific target. <br><strong>Core
                      Idea:</strong> The canonical hash map problem. As you iterate through the
                    array, for each number `x`, check if `target - x` exists in your hash map. If it
                    does, you've found a solution. If not, add `x` and its index to the map for
                    future lookups. This turns an $O(n^2)$ brute-force solution into an $O(n)$ one.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Group Anagrams</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given an array of strings, group the anagrams together. <br><strong>Core
                      Idea:</strong> The key insight is that all anagrams become identical when
                    their characters are sorted. Use a hash map where the key is the *sorted*
                    version of a string, and the value is a list of all its original anagrams.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/contains-duplicate/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Contains Duplicate</a> -
                  <span class="text-sm font-semibold bg-green-200 text-green-800 px-2 py-1 rounded">Easy</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Determine if an array contains any duplicate values. <br><strong>Core
                      Idea:</strong> The perfect use case for a Hash Set. Iterate through the
                    array. For each element, try to add it to the set. If the element is already in
                    the set, you've found a duplicate and can return `true` immediately.</p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/"
                    target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">Longest Substring Without
                    Repeating Characters</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Find the length of the longest substring without repeating characters.
                    <br><strong>Core Idea:</strong> A classic "sliding window" problem powered by a
                    hash map (or set). Use the hash map to store the most recent index of each
                    character in your current window. If you encounter a character that's already in
                    the map, you must move the start of your window to the right of its last seen
                    position.
                  </p>
                </li>
                <li>
                  <a href="https://leetcode.com/problems/4sum-ii/" target="_blank" rel="noopener noreferrer"
                    class="text-indigo-500 hover:underline font-semibold">4Sum II</a> - <span
                    class="text-sm font-semibold bg-yellow-200 text-yellow-800 px-2 py-1 rounded">Medium</span>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Problem:</strong>
                    Given four lists of integers, find the number of tuples `(i, j, k, l)` such that
                    `A[i] + B[j] + C[k] + D[l]` is zero. <br><strong>Core Idea:</strong> A
                    brute-force $O(n^4)$ solution is too slow. Use a hash map to pre-compute and
                    store the sums of all pairs from lists A and B. Then, iterate through lists C
                    and D, and for each pair sum `c + d`, check the map for the existence of its
                    negation, `-(c + d)`.</p>
                </li>
              </ul>
            </details>

            <div class="mt-12 flex justify-between">
              <a href="#dsu" class="nav-button font-semibold py-2 px-6 rounded-lg shadow-sm"><i
                  class="fas fa-arrow-left mr-2"></i> Prev: Disjoint Set Union</a>
              <span></span> <!-- Placeholder for next button if this is the last topic -->
            </div>
          </section>

        </div>

        <div id="noResultsMessage" class="hidden text-center py-16">
          <i class="fas fa-search text-4xl text-gray-400 mb-4"></i>
          <h3 class="text-2xl font-bold text-gray-600 dark:text-gray-400">No topics found</h3>
          <p class="text-gray-500">Try a different search term.</p>
        </div>
        <footer class="mt-16 text-center text-sm text-gray-500">
          <p>&copy; 2025 CodeMaster Pro. All rights reserved.</p>
        </footer>
      </main>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize Animations on Scroll
      AOS.init({ duration: 500, once: true, delay: 50 });

      const mainContent = document.getElementById('main-content');
      const sidebar = document.getElementById('sidebar');

      // --- THEME (DARK/LIGHT MODE) ---
      const themeToggle = document.getElementById('themeToggle');
      const sunIcon = themeToggle.querySelector('.fa-sun');
      const moonIcon = themeToggle.querySelector('.fa-moon');
      const userTheme = localStorage.getItem('theme');
      const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches;

      const setTheme = (theme) => {
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
        if (theme === 'dark') {
          sunIcon.style.display = 'none'; moonIcon.style.display = 'block';
        } else {
          sunIcon.style.display = 'block'; moonIcon.style.display = 'none';
        }
      };

      setTheme(userTheme ? userTheme : (systemTheme ? 'dark' : 'light'));

      themeToggle.addEventListener('click', () => {
        setTheme(document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark');
      });

      // --- TAB SWITCHING LOGIC ---
      document.querySelectorAll('.code-tabs').forEach(tabGroup => {
        tabGroup.querySelectorAll('.tab-btn').forEach(button => {
          button.addEventListener('click', () => {
            tabGroup.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            const tabId = button.dataset.tab;
            const contentContainer = tabGroup.closest('.topic-section, .p-6.rounded-xl');
            contentContainer.querySelectorAll('.tab-content').forEach(content => content.classList.add('hidden'));
            contentContainer.querySelector(`#${tabId}`).classList.remove('hidden');
          });
        });
      });

      // --- COPY CODE BUTTON LOGIC ---
      document.querySelectorAll('pre').forEach(pre => {
        const button = document.createElement('button');
        button.className = 'copy-code-btn';
        button.innerHTML = '<i class="fas fa-copy"></i>';
        button.title = 'Copy code';
        pre.appendChild(button);

        button.addEventListener('click', () => {
          const code = pre.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.innerHTML = '<i class="fas fa-check"></i>';
            setTimeout(() => { button.innerHTML = '<i class="fas fa-copy"></i>'; }, 2000);
          });
        });
      });

      // --- READING PROGRESS BAR ---
      const progressBar = document.getElementById('progressBar');
      window.addEventListener('scroll', () => {
        const scrollableHeight = document.documentElement.scrollHeight - window.innerHeight;
        const scrolled = (window.scrollY / scrollableHeight) * 100;
        progressBar.style.width = `${scrolled}%`;
      });

      // --- SIDEBAR ACTIVE LINK ON SCROLL ---
      const sidebarLinks = document.querySelectorAll('.sidebar-link');
      const sections = document.querySelectorAll('.topic-section');
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const id = entry.target.getAttribute('id');
            sidebarLinks.forEach(link => {
              link.classList.remove('active');
              if (link.getAttribute('href') === `#${id}`) {
                link.classList.add('active');
              }
            });
          }
        });
      }, {
        root: null,
        rootMargin: '0px 0px -50% 0px'
      });
      sections.forEach(section => observer.observe(section));

      // --- PROGRESS TRACKING ---
      document.querySelectorAll('.progress-checkbox').forEach(checkbox => {
        const topicId = checkbox.parentElement.dataset.topicId;
        if (localStorage.getItem(topicId) === 'true') {
          checkbox.checked = true;
          checkbox.parentElement.classList.add('topic-completed');
        }
        checkbox.addEventListener('change', (e) => {
          localStorage.setItem(topicId, e.target.checked);
          checkbox.parentElement.classList.toggle('topic-completed', e.target.checked);
        });
      });

      // --- SEARCH FUNCTIONALITY [CORRECTED] ---
      const searchInput = document.getElementById('searchInput');
      const sectionsContainer = document.getElementById('sections-container');
      const mainHeader = document.querySelector('main > header');
      const noResultsMessage = document.getElementById('noResultsMessage');

      searchInput.addEventListener('keyup', (e) => {
        const searchTerm = e.target.value.toLowerCase();
        let hasResults = false;

        sections.forEach(section => {
          const title = section.querySelector('h2').innerText.toLowerCase();
          const content = section.innerText.toLowerCase();
          const isMatch = title.includes(searchTerm) || content.includes(searchTerm);

          section.style.display = isMatch ? 'block' : 'none';
          if (isMatch) {
            hasResults = true;
          }
        });

        // Now, show/hide the containers based on the results
        const showContent = hasResults || searchTerm === '';

        mainHeader.style.display = showContent ? 'block' : 'none';
        sectionsContainer.style.display = showContent ? 'block' : 'none';
        noResultsMessage.style.display = showContent ? 'none' : 'block';
      });
    });
  </script>
</body>

</html>